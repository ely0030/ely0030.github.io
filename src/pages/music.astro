---
import Layout from '../layouts/BlogPost.astro';

// Manual track list with external URLs
// All files hosted on Catbox - no local file system scanning
const tracks = [
	// {
	// 	name: 'Be My Glock.mp3',
	// 	artist: 'Daniel Caesar',
	// 	url: 'https://files.catbox.moe/tia4sx.mp3',
	// 	size: '8.4mb',
	// 	modified: '12.11.25 10:29'
	// },
	{
		name: 'Bel Air Hotel.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/as08h7.mp3',
		size: '8.8mb',
		modified: '12.11.25 10:32'
	},
	{
		name: "Can't.mp3",
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/qnr67h.mp3',
		size: '8.45mb',
		modified: '12.11.25 15:30'
	},
	{
		name: "C'est La Vie.mp3",
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/v99y5h.mp3',
		size: '4.6mb',
		modified: '5.7.24 22:40'
	},
	// {
	// 	name: "D'angelo - Inst. #5 (rare).mp3",
	// 	artist: "D'Angelo",
	// 	url: 'https://files.catbox.moe/3jy7bb.mp3',
	// 	size: '7.2mb',
	// 	modified: '26.10.24 18:04'
	// },
	{
		name: 'Danny Scissorhands.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/shirg1.mp3',
		size: '~8mb',
		modified: '12.11.25 16:00'
	},
	{
		name: 'DNA.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/an2j6r.mp3',
		size: '6mb',
		modified: '13.3.25 00:00'
	},
	{
		name: 'Easy.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/82k6va.mp3',
		size: '5mb',
		modified: '2.7.24 23:44'
	},
	{
		name: 'Finger.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/9ov7nc.mp3',
		size: '5.5mb',
		modified: '12.11.25 10:35'
	},
	{
		name: 'Fly You Out.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/o3n3cd.mp3',
		size: '5.7mb',
		modified: '3.7.24 03:29'
	},
	{
		name: 'Girls Lie Too.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/nw677u.mp3',
		size: '4mb',
		modified: '12.11.25 10:24'
	},
	{
		name: 'Hope Is.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/25e7r9.mp3',
		size: '~5mb',
		modified: '27.1.26 00:00'
	},
	{
		name: 'Its Not Your Fault (2022).mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/g1g6ud.mp3',
		size: '9mb',
		modified: '12.11.25 10:37'
	},
	{
		name: 'Jealousy.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/2vhi4p.mp3',
		size: '5.5mb',
		modified: '5.9.24 00:00'
	},
	// {
	// 	name: 'Me And You (ROUGH).mp3',
	// 	artist: 'Daniel Caesar',
	// 	url: 'https://files.catbox.moe/nah41b.mp3',
	// 	size: '2.1mb',
	// 	modified: '12.11.25 10:30'
	// },
	{
		name: 'On My Own.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/it86km.mp3',
		size: '9.9mb',
		modified: '12.11.25 10:25'
	},
	{
		name: 'Pestilence.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/vxz22l.mp3',
		size: '6.1mb',
		modified: '12.11.25 10:42'
	},
	// {
	// 	name: 'PIGALLE.mp3',
	// 	artist: 'Daniel Caesar',
	// 	url: 'https://files.catbox.moe/im2xps.mp3',
	// 	size: '11mb',
	// 	modified: '12.11.25 10:28'
	// },
	{
		name: 'Shame.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/h0yv4u.mp3',
		size: '~8mb',
		modified: '12.11.25 15:45'
	},
	{
		name: 'Sneaking Around.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/z8kys1.mp3',
		size: '7.8mb',
		modified: '12.11.25 11:38'
	},
	// {
	// 	name: 'SUPERPOWERS.mp3',
	// 	artist: 'Daniel Caesar',
	// 	url: 'https://files.catbox.moe/bqh1yg.mp3',
	// 	size: '7.2mb',
	// 	modified: '12.11.25 10:27'
	// },
	{
		name: 'Till The Day (ft. Sampha).mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/2kzc78.mp3',
		size: '12mb',
		modified: '12.11.25 10:25'
	},
	{
		name: 'Casanova Complex.m4a',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/omimd5.m4a',
		size: '2.24mb',
		modified: '18.11.25 00:00'
	},
	{
		name: 'If Only A Friend (live).mp3',
		artist: 'Sampha',
		url: 'https://files.catbox.moe/rt57xn.mp3',
		size: '1.98mb',
		modified: '18.11.25 00:00'
	},
	// {
	// 	name: "Wasn't There.mp3",
	// 	artist: 'Anna Wise',
	// 	url: 'https://files.catbox.moe/aixl4a.mp3',
	// 	size: '1.18mb',
	// 	modified: '18.11.25 00:00'
	// },
	{
		name: 'Root_of_all_Evil_live.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/1xw24j.mp3',
		size: '12.3mb',
		modified: '18.11.25 00:00'
	},
	{
		name: 'Master Yourself.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/viiywc.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'New Life.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/yhnp0u.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Post Modernity.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/zevuup.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'PROJECTING ME.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/b3t2kb.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Indecision.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/rfepvw.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'For Once In My Life.mp3',
		artist: 'Monica Martin, James Blake',
		url: 'https://files.catbox.moe/kclwal.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'peter-collins-1.mp3',
		artist: 'Peter Collins',
		url: '/music/peter-collins-1.mp3',
		size: '0.5mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Midnight in Majorca.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/dd2se0.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Pussy.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/sqr5yb.mp3',
		size: '?mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Sweet Emily (live).m4a',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/41bgv2.m4a',
		size: '5.3mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Dope.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/olc4j8.MP3',
		size: '2mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Sweet.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/zobts5.mp3',
		size: '8.9mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Salvation On Mt. Olympus.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/akw2x2.mp3',
		size: '11.2mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'Eye Of Mine.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/wdeeby.mp3',
		size: '4.1mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'YoBro.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/mfe88g.mp3',
		size: '10.4mb',
		modified: '25.1.26 00:00'
	},
	{
		name: 'letscashhhout.mp3',
		artist: 'Mk.gee',
		url: 'https://files.catbox.moe/olf9nh.mp3',
		size: '8.1mb',
		modified: '26.1.26 00:00'
	},
	{
		name: 'Bang Bang.mp3',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/32bl7h.mp3',
		size: '8.7mb',
		modified: '26.1.26 00:00'
	},
	{
		name: 'Changing Me.m4a',
		artist: 'Daniel Caesar',
		url: 'https://files.catbox.moe/du564t.m4a',
		size: '2.1mb',
		modified: '26.1.26 00:00'
	}
];

// Sort alphabetically
tracks.sort((a, b) => a.name.localeCompare(b.name));
---

<Layout
	title="ely0030 | Music"
	description="Free MP3 downloads and unreleased tracks"
	pubDate={new Date()}
	pageType="literature"
	heroImage="/music-banner.jpg"
>
	<div class="directory-listing">
		<h1><a href="/">Index</a> of /music</h1>

		<table>
			<thead>
				<tr>
					<th class="col-play"></th>
					<th class="col-name">Name</th>
					<th class="col-modified">Last modified</th>
					<th class="col-duration">Duration</th>
					<th class="col-size">Size</th>
				</tr>
			</thead>
			<tbody>
				<tr class="parent">
					<td class="col-play"></td>
					<td class="col-name"><a href="/">..</a></td>
					<td class="col-modified">-</td>
					<td class="col-duration">-</td>
					<td class="col-size">-</td>
				</tr>
				{tracks.map(track => (
					<tr class="file" data-audio-src={track.url}>
						<td class="col-play">
							<button class="play-btn" aria-label={`Play ${track.name}`}>▶</button>
						</td>
						<td class="col-name">
							<span class="track-name">{track.name}</span>
							<span class="track-artist">{track.artist}</span>
						</td>
						<td class="col-modified">{track.modified}</td>
						<td class="col-duration">-</td>
						<td class="col-size">
							<a href={`/download-proxy/?url=${encodeURIComponent(track.url)}&filename=${encodeURIComponent(track.name)}`} class="size-link" download={track.name}>{track.size}</a>
						</td>
					</tr>
				))}
			</tbody>
		</table>

		<audio id="audio-player" preload="metadata"></audio>

		<!-- Autonomous pin - lives outside mini player! -->
		<div id="autonomous-pin" class="autonomous-pin hidden">
			<div class="pin-touch-target"></div>
			<div class="pin-head"></div>
			<div class="pin-needle"></div>
		</div>

		<!-- Touch loupe - magnifies what's under thumb when dragging pin -->
		<div id="touch-loupe" class="touch-loupe hidden">
			<div class="loupe-viewport"></div>
			<div class="loupe-crosshair"></div>
		</div>

		<!-- Mini floating player -->
		<div id="mini-player" class="mini-player hidden">
			<div class="mini-player-track">
				<span class="mini-track-name">-</span>
				<span class="mini-track-queued hidden"> → <span class="queued-name">-</span></span>
				<div class="mini-artist-line">
					<span class="mini-track-artist">-</span>
					<span class="mini-artist-queued hidden"> → <span class="queued-artist-name">-</span></span>
				</div>
			</div>
			<div class="mini-player-progress">
				<span class="mini-current-time">0:00</span>
				<div class="mini-progress-bar">
					<div class="mini-progress-fill"></div>
				</div>
				<span class="mini-duration">0:00</span>
			</div>
			<div class="mini-player-controls">
				<button class="mini-shuffle-btn" aria-label="Toggle shuffle">⤨</button>
				<div class="mini-player-main">
					<button class="mini-prev-btn" aria-label="Previous track">⏮</button>
					<button class="mini-play-btn" aria-label="Play/Pause">▶</button>
					<button class="mini-next-btn" aria-label="Next track">⏭</button>
				</div>
				<div class="mini-volume-wrapper">
					<input type="range" class="mini-volume-slider" min="0" max="100" value="100" aria-label="Volume">
				</div>
			</div>
		</div>
	</div>

	<style>
		.directory-listing {
			font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Courier New', monospace;
			font-size: 12px;
			line-height: 1.4;
			max-width: 100%;
		}

		h1 {
			font-size: 14px;
			font-weight: 400;
			margin: 0 0 8px 0;
			color: #1d1d1f;
			letter-spacing: 0;
			cursor: default !important;
		}

		h1 a,
		h1 a:hover,
		h1 a:visited,
		h1 a:active,
		h1 a:focus {
			color: #1d1d1f !important;
			text-decoration: none !important;
			border: none !important;
			border-bottom: none !important;
			background: none !important;
			box-shadow: none !important;
			cursor: pointer !important;
			outline: none !important;
		}

		hr {
			border: none;
			border-top: 1px solid #1d1d1f;
			margin: 8px 0 12px 0;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			margin: 0;
		}

		thead th {
			text-align: left;
			font-weight: 400;
			padding: 4px 12px 4px 0;
			color: #1d1d1f;
			border-bottom: 1px solid #1d1d1f;
			font-size: 11px;
			letter-spacing: 0;
		}

		thead th.col-play {
			width: 18px;
			padding: 0;
			border: none;
		}

		tbody td {
			padding: 5px 12px 5px 0;
			color: #1d1d1f;
			border-bottom: 1px solid #e5e5e5;
			font-size: 12px;
		}

		tbody td.col-play {
			width: 18px;
			padding: 0 8px 0 0;
			border: none;
			background: none !important;
		}

		tbody tr:last-child td {
			border-bottom: none;
		}

		.col-name {
			width: 50%;
		}

		.track-name {
			display: block;
		}

		.track-artist {
			display: block;
			font-size: 10px;
			color: #666;
			margin-top: 2px;
		}

		.col-modified,
		th.col-modified {
			display: none; /* Hidden for now */
		}

		.col-duration,
		thead th.col-duration {
			width: 12%;
			white-space: nowrap;
			text-align: center;
			padding-right: 40px !important;
		}

		.col-size,
		thead th.col-size {
			width: 10%;
			text-align: center;
		}

		.size-link {
			color: #0066CC;
			text-decoration: none;
			border-bottom: 1px solid transparent;
			transition: all 0.2s ease;
		}

		.size-link:hover {
			border-bottom-color: #0066CC;
			opacity: 0.8;
		}

		.play-btn {
			background: none;
			border: none;
			color: #1d1d1f;
			font-size: 9px;
			cursor: pointer;
			padding: 0;
			margin: 0;
			width: 10px;
			height: auto;
			line-height: 1;
			font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Courier New', monospace;
			text-align: left;
			display: inline-block;
			position: relative;
		}

		.play-btn:hover {
			opacity: 0.6;
		}

		.play-btn:focus {
			outline: none;
		}

		.playing .play-btn {
			left: -1px;
		}

		#audio-player {
			display: none;
		}

		a {
			color: #1d1d1f;
			text-decoration: none;
			border-bottom: 1px solid transparent;
			transition: border-bottom-color 0.15s ease;
		}

		a:hover {
			border-bottom-color: #1d1d1f;
		}

		.parent a {
			font-weight: 600;
		}

		.parent td {
			text-align: center;
		}

		.parent .col-name {
			text-align: left;
		}

		.preview-section {
			margin-top: 30px;
		}

		.audio-preview {
			width: 100%;
			max-width: 600px;
			height: 32px;
		}

		/* Mobile responsive */
		@media (max-width: 1000px) {
			h1 {
				font-size: 13px;
			}

			thead th.col-modified,
			thead th.col-duration {
				display: none;
			}

			tbody td.col-play {
				padding-right: 8px;
				width: 20px;
			}

			tbody td.col-modified,
			tbody td.col-duration {
				display: none;
			}

			.col-name {
				width: 65%;
				padding-right: 8px;
			}

			.col-size {
				width: 25%;
			}

			.play-btn {
				font-size: 9px;
				width: 12px;
			}

			.playing .play-btn {
				left: -1px;
			}
		}

		/* Mini floating player */
		.mini-player {
			position: fixed;
			bottom: 20px;
			right: 20px;
			background: rgba(255, 255, 255, 0.75);
			backdrop-filter: blur(20px) saturate(180%);
			-webkit-backdrop-filter: blur(20px) saturate(180%);
			border: 1px solid rgba(255, 255, 255, 0.4);
			border-radius: 14px;
			padding: 14px 18px;
			font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Courier New', monospace;
			font-size: 11px;
			z-index: 1000;
			min-width: 240px;
			box-shadow:
				0 4px 24px rgba(0, 0, 0, 0.12),
				0 1px 3px rgba(0, 0, 0, 0.08),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
			cursor: grab;
			user-select: none;
			-webkit-user-select: none;
			touch-action: none;
			-webkit-touch-callout: none;
			transition: box-shadow 0.2s ease, transform 0.2s ease;
		}

		.mini-player.pinned {
			position: absolute;
			/* Pinned = flat against page, minimal shadow */
			box-shadow:
				0 1px 3px rgba(0, 0, 0, 0.08),
				0 0 1px rgba(0, 0, 0, 0.05),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
		}

		/* Spawning state - very subtle shadow on initial appearance */
		.mini-player.pinned.spawning {
			box-shadow:
				0 1px 4px rgba(0, 0, 0, 0.09),
				0 0 2px rgba(0, 0, 0, 0.04),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
			transition: box-shadow 0.25s ease-out;
		}

		.mini-player.pinned::after {
			content: '';
			position: absolute;
			bottom: -6px;
			left: 50%;
			transform: translateX(-50%);
			width: 1px;
			height: 6px;
			background: linear-gradient(to bottom, rgba(0,0,0,0.15), transparent);
		}

		/* Autonomous pin - completely independent element! */
		.autonomous-pin {
			position: fixed;
			width: 20px;
			height: 30px;
			pointer-events: none;
			z-index: 1001;
			transition: opacity 0.2s ease;
		}

		/* Pin uses absolute positioning when card is pinned to page */
		.autonomous-pin.pinned {
			position: absolute;
		}

		/* Pin is grabbable when resting on the card */
		.autonomous-pin.resting {
			pointer-events: auto;
			cursor: grab;
			touch-action: none;
			-webkit-touch-callout: none;
		}

		/* When pin is on table (not mini player), it should be BEHIND mini player */
		.autonomous-pin.on-table {
			z-index: 999;
		}

		.autonomous-pin.resting:active {
			cursor: grabbing;
		}

		.autonomous-pin.dragging {
			pointer-events: auto;
			cursor: grabbing;
			z-index: 1002;
		}

		/* Pin tacked into the page - z-index below mini player so card passes over it */
		.autonomous-pin.tacked {
			position: absolute;
			pointer-events: auto;
			cursor: pointer;
			z-index: 999;
			touch-action: none;
			-webkit-touch-callout: none;
		}

		.autonomous-pin.tacked .pin-head {
			box-shadow:
				0 1px 2px rgba(0,0,0,0.4),
				inset 0 -1px 2px rgba(0,0,0,0.2);
		}

		.autonomous-pin.tacked .pin-needle {
			height: 0;
			opacity: 0;
		}

		/* Tacking animation - needle drives into page at angle
		   Pin is tilted 15deg, so it enters diagonally (down + left)
		   tan(15deg) ≈ 0.27, so for every 10px down, move ~2.7px left */
		@keyframes pin-tack-into-page {
			0% {
				transform: translate(0, 0);
			}
			50% {
				/* Drive in - move down and left at the needle angle */
				transform: translate(-2px, 8px);
			}
			70% {
				/* Small bounce back */
				transform: translate(-0.5px, 2px);
			}
			100% {
				/* Settled position */
				transform: translate(-1px, 4px);
			}
		}

		.autonomous-pin.tacking {
			animation: pin-tack-into-page 0.2s ease-out forwards;
		}

		/* Needle shrink animation for tacking - driven by JS */
		.autonomous-pin.tacking .pin-needle {
			transition: height 0.2s ease-out, opacity 0.2s ease-out;
		}

		.autonomous-pin.hidden {
			opacity: 0;
			pointer-events: none;
		}

		.autonomous-pin .pin-head {
			position: absolute;
			top: 1px;
			left: 6.5px;
			width: 8px;
			height: 8px;
			background: radial-gradient(circle at 35% 35%, #ff7b7b, #c0392b);
			border-radius: 50%;
			box-shadow:
				0 2px 4px rgba(0,0,0,0.4),
				inset 0 -1px 2px rgba(0,0,0,0.2);
			transform-origin: center center;
			z-index: 2;
		}

		.autonomous-pin .pin-needle {
			position: absolute;
			top: 7px;
			left: 9px;
			width: 2px;
			height: 15px;
			background: linear-gradient(to bottom, #c8ccd0, #9a9ea3, #6a6e73);
			border-radius: 0 0 1px 1px;
			transform-origin: top center;
			z-index: 1;
		}

		/* Larger touch target for mobile - invisible but grabbable */
		.autonomous-pin .pin-touch-target {
			position: absolute;
			top: -20px;
			left: -20px;
			width: 60px;
			height: 60px;
			border-radius: 50%;
			/* Invisible but captures touch */
			background: transparent;
			z-index: 3;
			/* Prevent browser gestures on touch target */
			touch-action: none;
			-webkit-touch-callout: none;
			/* Debug: uncomment to see touch area */
			/* background: rgba(255, 0, 0, 0.2); */
		}

		/* Touch loupe - magnifying glass showing what's under thumb */
		.touch-loupe {
			position: fixed;
			width: 160px;
			height: 160px;
			border-radius: 50%;
			background: #f8f8f8;
			border: 3px solid #333;
			box-shadow:
				0 8px 32px rgba(0, 0, 0, 0.3),
				0 2px 8px rgba(0, 0, 0, 0.2);
			overflow: hidden;
			pointer-events: none;
			z-index: 2000;
			transform: translateX(-50%);
			transition: opacity 0.1s ease, border-color 0.15s ease;
		}

		/* Glass lens effect overlay */
		.touch-loupe::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: radial-gradient(
				ellipse at 30% 30%,
				rgba(255, 255, 255, 0.5) 0%,
				rgba(255, 255, 255, 0.2) 30%,
				transparent 60%
			);
			border-radius: 50%;
			pointer-events: none;
			z-index: 100;
		}

		.touch-loupe.hidden {
			opacity: 0;
			pointer-events: none;
		}

		/* Viewport contains the magnified clone of page content */
		.touch-loupe .loupe-viewport {
			position: absolute;
			top: 0;
			left: 0;
			/* Will be sized dynamically to hold the cloned content */
			pointer-events: none;
		}

		/* Cloned content inside viewport */
		.touch-loupe .loupe-viewport .loupe-clone {
			position: absolute;
			top: 0;
			left: 0;
			pointer-events: none;
		}

		/* Pin indicator in loupe - shows where pin will drop */
		.touch-loupe .loupe-crosshair {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -100%);  /* Needle TIP at center */
			pointer-events: none;
			z-index: 50;
			width: 20px;
			height: 28px;
		}

		/* Pin needle - BEHIND head, tip at bottom (drop point) */
		.touch-loupe .loupe-crosshair::before {
			content: '';
			position: absolute;
			bottom: 0;
			left: 50%;
			transform: translateX(-50%) rotate(15deg);
			transform-origin: bottom center;
			width: 2px;
			height: 16px;
			background: linear-gradient(to bottom, #c8ccd0, #666);
			border-radius: 1px 1px 0 0;
			z-index: 1;
		}

		/* Pin head - on top of needle */
		.touch-loupe .loupe-crosshair::after {
			content: '';
			position: absolute;
			top: 0;
			left: calc(50% + 6px);
			transform: translateX(-50%);
			width: 14px;
			height: 14px;
			background: radial-gradient(circle at 35% 35%, #ff7b7b, #c0392b);
			border-radius: 50%;
			box-shadow:
				0 2px 4px rgba(0,0,0,0.4),
				inset 0 -2px 3px rgba(0,0,0,0.2);
			z-index: 2;
		}

		/* Loupe border color based on target */
		.touch-loupe[data-target="loop-track"],
		.touch-loupe[data-target="loop-artist"] {
			border-color: #0066CC;
			box-shadow:
				0 8px 32px rgba(0, 102, 204, 0.4),
				0 2px 8px rgba(0, 0, 0, 0.2),
				inset 0 0 40px rgba(0, 102, 204, 0.05);
		}

		.touch-loupe[data-target="table-track"],
		.touch-loupe[data-target="table-artist"] {
			border-color: #0066CC;
			box-shadow:
				0 8px 32px rgba(0, 102, 204, 0.4),
				0 2px 8px rgba(0, 0, 0, 0.2),
				inset 0 0 40px rgba(0, 102, 204, 0.05);
		}

		.touch-loupe[data-target="mini-player"] {
			border-color: #4CAF50;
			box-shadow:
				0 8px 32px rgba(76, 175, 80, 0.4),
				0 2px 8px rgba(0, 0, 0, 0.2),
				inset 0 0 40px rgba(76, 175, 80, 0.05);
		}

		.touch-loupe[data-target="none"] {
			border-color: #999;
		}

		/* Pin resting on card - needle hidden */
		.autonomous-pin.resting .pin-needle {
			height: 0;
			opacity: 0;
		}

		.autonomous-pin.resting .pin-head {
			box-shadow:
				0 1px 2px rgba(0,0,0,0.3),
				inset 0 -1px 2px rgba(0,0,0,0.2);
		}

		/* Pin gave up - chilling */
		.autonomous-pin.gave-up {
			opacity: 0.8;
		}

		.autonomous-pin.gave-up .pin-head,
		.autonomous-pin.gave-up .pin-needle {
			transition: transform 0.15s ease-out;
		}

		/* Impact animation when pin tacks - transitions from elevated to flat
		   Card is held up (.gliding) until pin tacks, then pressed into page */
		@keyframes pin-impact {
			0% {
				/* Start elevated (matches .pinned.gliding) */
				transform: translateY(0) scale(1);
				box-shadow:
					0 12px 48px rgba(0, 0, 0, 0.2),
					0 4px 12px rgba(0, 0, 0, 0.12),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
			50% {
				/* Pressed INTO the page by pin */
				transform: translateY(2px) scale(0.99);
				box-shadow:
					0 0 1px rgba(0, 0, 0, 0.04),
					0 0 0 rgba(0, 0, 0, 0),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
			100% {
				/* Settled flat - matches .pinned state */
				transform: translateY(0) scale(1);
				box-shadow:
					0 1px 3px rgba(0, 0, 0, 0.08),
					0 0 1px rgba(0, 0, 0, 0.05),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
		}

		/* For manual re-pin: starts from unpinned floating shadow (moderate) */
		@keyframes pin-impact-from-float {
			0% {
				/* Start at unpinned floating shadow (matches base .mini-player) */
				transform: translateY(0) scale(1);
				box-shadow:
					0 4px 24px rgba(0, 0, 0, 0.12),
					0 1px 3px rgba(0, 0, 0, 0.08),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
			50% {
				/* Pressed INTO the page by pin */
				transform: translateY(2px) scale(0.99);
				box-shadow:
					0 0 1px rgba(0, 0, 0, 0.04),
					0 0 0 rgba(0, 0, 0, 0),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
			100% {
				/* Settled flat - matches .pinned state */
				transform: translateY(0) scale(1);
				box-shadow:
					0 1px 3px rgba(0, 0, 0, 0.08),
					0 0 1px rgba(0, 0, 0, 0.05),
					inset 0 1px 0 rgba(255, 255, 255, 0.5);
			}
		}

		.mini-player.pinned.just-pinned {
			animation: pin-impact 0.2s ease-out forwards;
		}

		.mini-player.pinned.just-pinned-from-float {
			animation: pin-impact-from-float 0.2s ease-out forwards;
		}

		.mini-player:hover:not(.dragging):not(.pinned):not(.gliding) {
			box-shadow:
				0 8px 32px rgba(0, 0, 0, 0.15),
				0 2px 6px rgba(0, 0, 0, 0.1),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
		}

		.mini-player.pinned:hover:not(.dragging):not(.gliding) {
			/* Pinned hover - still flat, just subtle highlight */
			box-shadow:
				0 1px 4px rgba(0, 0, 0, 0.1),
				0 0 2px rgba(0, 0, 0, 0.06),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
		}

		.mini-player.dragging:not(.pinned) {
			cursor: grabbing;
			box-shadow:
				0 12px 48px rgba(0, 0, 0, 0.2),
				0 4px 12px rgba(0, 0, 0, 0.12),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
			transform: scale(1.02);
			transition: none;
		}

		.mini-player.gliding:not(.pinned) {
			/* Gliding unpinned = regular floating shadow, not elevated */
			cursor: grabbing;
			box-shadow:
				0 4px 24px rgba(0, 0, 0, 0.12),
				0 1px 3px rgba(0, 0, 0, 0.08),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
			transition: none;
		}

		.mini-player.pinned.dragging,
		.mini-player.pinned.gliding {
			/* Dragging/gliding pinned = lifted off page, full floating shadow */
			cursor: grabbing;
			box-shadow:
				0 12px 48px rgba(0, 0, 0, 0.2),
				0 4px 12px rgba(0, 0, 0, 0.12),
				inset 0 1px 0 rgba(255, 255, 255, 0.5);
			transition: none;
		}

		.mini-player.hidden {
			display: none;
		}

		.mini-player-track {
			margin-bottom: 8px;
		}

		.mini-track-name {
			display: inline;
			font-weight: 500;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			max-width: 220px;
		}

		.mini-track-queued {
			display: none;
			color: #999;
			font-size: 11px;
			white-space: nowrap;
		}

		.mini-track-queued:not(.hidden) {
			display: inline;
		}

		.mini-track-queued .queued-name {
			color: #888;
		}

		.mini-artist-line {
			display: block;
		}

		.mini-track-artist {
			display: inline;
			font-size: 10px;
			color: #666;
		}

		.mini-artist-queued {
			display: none;
			color: #999;
			font-size: 10px;
			white-space: nowrap;
		}

		.mini-artist-queued:not(.hidden) {
			display: inline;
		}

		.mini-artist-queued .queued-artist-name {
			color: #888;
		}

		.mini-player-progress {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 10px;
		}

		.mini-current-time,
		.mini-duration {
			font-size: 10px;
			color: #666;
			min-width: 32px;
		}

		.mini-current-time {
			text-align: right;
		}

		.mini-progress-bar {
			flex: 1;
			height: 4px;
			background: rgba(0, 0, 0, 0.1);
			cursor: pointer;
			position: relative;
			border-radius: 2px;
			overflow: hidden;
			/* Allow horizontal touch on progress bar */
			touch-action: pan-x;
			-webkit-tap-highlight-color: transparent;
		}

		.mini-progress-fill {
			height: 100%;
			background: linear-gradient(90deg, #666, #333);
			width: 0%;
			transition: width 0.1s linear;
			border-radius: 2px;
		}

		.mini-player-controls {
			display: flex;
			justify-content: center;
			align-items: center;
			position: relative;
		}

		.mini-player-controls button {
			background: none;
			border: none;
			font-size: 14px;
			cursor: pointer;
			padding: 8px;
			color: #1d1d1f;
			/* iOS consistency fixes */
			-webkit-appearance: none;
			appearance: none;
			-webkit-tap-highlight-color: transparent;
			touch-action: manipulation;
		}

		.mini-player-controls button:hover {
			opacity: 0.6;
		}

		.mini-player-controls button:active {
			opacity: 0.4;
		}

		.mini-player-controls button:focus {
			outline: none;
		}

		.mini-shuffle-btn {
			margin-right: 8px;
			display: flex;
			align-items: center;
			position: relative;
		}

		.mini-player-controls .mini-shuffle-btn.active {
			color: #0066CC;
		}

		.mini-player-main {
			display: flex;
			align-items: center;
			gap: 4px;
		}

		.mini-volume-wrapper {
			position: absolute;
			right: 12px;
			display: flex;
			align-items: center;
			cursor: pointer;
		}

		.mini-volume-slider {
			width: 28px;
			height: 16px;
			-webkit-appearance: none;
			appearance: none;
			background: transparent;
			cursor: pointer;
			outline: none;
		}

		.mini-volume-slider::-webkit-slider-runnable-track {
			width: 100%;
			height: 2px;
			background: linear-gradient(to right, #1d1d1f var(--volume-fill, 100%), rgba(0,0,0,0.1) var(--volume-fill, 100%));
			border-radius: 1px;
		}

		.mini-volume-slider::-moz-range-track {
			width: 100%;
			height: 2px;
			background: linear-gradient(to right, #1d1d1f var(--volume-fill, 100%), rgba(0,0,0,0.1) var(--volume-fill, 100%));
			border-radius: 1px;
		}

		.mini-volume-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 0;
			height: 0;
			margin-top: -1px;
		}

		.mini-volume-slider::-moz-range-thumb {
			width: 0;
			height: 0;
			border: none;
			background: transparent;
		}

		/* Loop mode styles - track loop */
		.mini-player-track.loop-mode .mini-track-name {
			color: #0066CC;
		}

		.mini-player-track.loop-mode .mini-track-name .extension {
			color: #1d1d1f;  /* Keep extension default color */
		}

		.mini-player-track.loop-mode .mini-track-name::after {
			content: '↻';
			font-size: 10px;
			margin-left: 5px;
			color: #0066CC;
			animation: loopIconFadeIn 0.15s ease-out;
		}

		/* Loop mode styles - artist loop */
		.mini-player-track.artist-loop-mode .mini-track-artist {
			color: #0066CC;
		}

		.mini-player-track.artist-loop-mode .mini-track-artist::after {
			content: '↻';
			font-size: 9px;
			margin-left: 4px;
			color: #0066CC;
			animation: loopIconFadeIn 0.15s ease-out;
		}

		/* Table element pinned state - when pin is tacked on table row */
		.track-name.pinned-loop,
		.track-artist.pinned-loop {
			color: #0066CC;
		}

		/* Loop symbol only on track names, not artist names */
		.track-name.pinned-loop::after {
			content: '↻';
			font-size: 9px;
			margin-left: 4px;
			color: #0066CC;
			animation: loopIconFadeIn 0.15s ease-out;
		}

		@keyframes loopIconFadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		@media (max-width: 1000px) {
			.mini-player:not(.dragged) {
				bottom: 10px;
				right: 10px;
				left: 10px;
				min-width: auto;
			}

			.mini-player.dragged {
				min-width: auto;
				max-width: calc(100vw - 20px);
			}

			.mini-track-name {
				max-width: none;
			}

			/* Larger touch targets on mobile (44px iOS minimum) */
			.mini-player-controls button {
				font-size: 16px;
				min-width: 44px;
				min-height: 44px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			/* Larger progress bar for easier touch */
			.mini-progress-bar {
				height: 8px;
				border-radius: 4px;
			}

			.mini-progress-fill {
				border-radius: 4px;
			}

			/* Hide volume slider on mobile - use device volume instead */
			.mini-volume-wrapper {
				display: none;
			}
		}
	</style>

	<script>
		const audioPlayer = document.getElementById('audio-player');
		const playButtons = document.querySelectorAll('.play-btn');
		let currentRow = null;
		let currentButton = null;
		let shuffleMode = false;
		let playedTracks = new Set();

		// Get all track rows (excluding parent row)
		const getAllTrackRows = () => {
			return Array.from(document.querySelectorAll('tr.file[data-audio-src]'));
		};

		// Get a random unplayed track
		const getRandomUnplayedTrack = () => {
			const allRows = getAllTrackRows();
			const unplayedRows = allRows.filter(row => {
				const audioSrc = row.getAttribute('data-audio-src');
				return !playedTracks.has(audioSrc);
			});

			// If all tracks have been played, reset the played set
			if (unplayedRows.length === 0) {
				playedTracks.clear();
				console.log('[Shuffle] All tracks played, resetting...');
				return allRows[Math.floor(Math.random() * allRows.length)];
			}

			return unplayedRows[Math.floor(Math.random() * unplayedRows.length)];
		};

		// Play a specific row
		const playRow = (row) => {
			if (!row) return;

			const audioSrc = row.getAttribute('data-audio-src');
			const button = row.querySelector('.play-btn');

			if (!audioSrc || !button) return;

			// Deactivate track loop mode when changing tracks
			// (track loop is specific to a track, not a setting)
			// But keep artist loop mode active
			if (typeof animatePinReturnToMiniPlayer === 'function' && pinOnTable && !artistLoopMode) {
				// Pin is on table - animate it flying back to mini player
				animatePinReturnToMiniPlayer();
			} else if (typeof deactivateLoopMode === 'function' && !artistLoopMode) {
				deactivateLoopMode();
			} else if (loopMode) {
				// If in track loop mode, deactivate it
				loopMode = false;
				miniPlayerTrack?.classList.remove('loop-mode');
			}

			// Stop current track
			if (currentButton) {
				currentButton.textContent = '▶';
				currentRow?.classList.remove('playing');
			}

			// Play new track
			audioPlayer.src = audioSrc;
			audioPlayer.play();
			button.textContent = '❚❚';
			row.classList.add('playing');

			currentRow = row;
			currentButton = button;

			// Track this song as played
			playedTracks.add(audioSrc);
		};

		// Play a row without deactivating loop mode (used for artist loop auto-play)
		const playRowWithoutDeactivatingLoop = (row) => {
			if (!row) return;

			const audioSrc = row.getAttribute('data-audio-src');
			const button = row.querySelector('.play-btn');

			if (!audioSrc || !button) return;

			// Stop current track
			if (currentButton) {
				currentButton.textContent = '▶';
				currentRow?.classList.remove('playing');
			}

			// Play new track
			audioPlayer.src = audioSrc;
			audioPlayer.play();
			button.textContent = '❚❚';
			row.classList.add('playing');

			currentRow = row;
			currentButton = button;

			// Track this song as played
			playedTracks.add(audioSrc);
		};

		playButtons.forEach(button => {
			button.addEventListener('click', (e) => {
				e.preventDefault();
				const row = button.closest('tr');
				const audioSrc = row.getAttribute('data-audio-src');

				if (!audioSrc) return;

				// If clicking the currently playing track
				if (currentRow === row) {
					if (audioPlayer.paused) {
						audioPlayer.play();
						button.textContent = '❚❚';
						row.classList.add('playing');
					} else {
						audioPlayer.pause();
						button.textContent = '▶';
						row.classList.remove('playing');
					}
				} else {
					// Stop current track and play new one
					if (currentButton) {
						currentButton.textContent = '▶';
						currentRow?.classList.remove('playing');
					}

					// If pin is on table, animate it flying back to mini player
					if (typeof animatePinReturnToMiniPlayer === 'function' && pinOnTable) {
						animatePinReturnToMiniPlayer();
					}

					audioPlayer.src = audioSrc;
					audioPlayer.play();
					button.textContent = '❚❚';
					row.classList.add('playing');

					currentRow = row;
					currentButton = button;

					// Track this song as played
					playedTracks.add(audioSrc);
				}
			});
		});

		// When audio ends, auto-play next track (or loop if loop mode active)
		audioPlayer.addEventListener('ended', () => {
			// Check for queued track first (pinned a different track on table)
			// Validate row still exists in DOM before using
			if (queuedLoopRow && document.contains(queuedLoopRow)) {
				const rowToPlay = queuedLoopRow;
				queuedLoopRow = null;  // Clear queue - next time it will loop
				hideQueuedTrack();  // Hide the "next up" indicator
				playRowWithoutDeactivatingLoop(rowToPlay);
				// Apply loop mode formatting after mini player updates
				// Now the queued track is playing, so show the loop symbol
				setTimeout(() => {
					if (loopMode) {
						const plainName = miniTrackNameEl.textContent;
						miniTrackNameEl.innerHTML = wrapExtension(plainName);
						miniPlayerTrack.classList.add('loop-mode');  // Now show loop symbol
					}
				}, 50);
				return;
			} else if (queuedLoopRow) {
				// Row was deleted from DOM - clear stale reference
				queuedLoopRow = null;
				hideQueuedTrack();
			}

			// Check for queued artist (pinned a different artist on table)
			if (queuedLoopArtist) {
				const artistToLoop = queuedLoopArtist.trim();  // Normalize whitespace
				queuedLoopArtist = null;  // Clear queue
				hideQueuedTrack();
				// Find first track by this artist
				const allRows = getAllTrackRows();
				const artistTracks = allRows.filter(row => {
					const artistEl = row.querySelector('.track-artist');
					return artistEl && artistEl.textContent.trim() === artistToLoop;
				});
				if (artistTracks.length > 0) {
					playRowWithoutDeactivatingLoop(artistTracks[0]);
					// Activate artist loop mode after mini player updates
					setTimeout(() => {
						activateArtistLoopMode(artistToLoop);
					}, 50);
				}
				return;
			}

			// Track loop mode: replay the same track
			if (loopMode) {
				audioPlayer.currentTime = 0;
				audioPlayer.play();
				return;
			}

			// Artist loop mode: play next track by the same artist
			if (artistLoopMode && loopArtist) {
				const allRows = getAllTrackRows();
				// Find all tracks by this artist (trim for consistent matching)
				const artistTracks = allRows.filter(row => {
					const artistEl = row.querySelector('.track-artist');
					return artistEl && artistEl.textContent.trim() === loopArtist.trim();
				});

				if (artistTracks.length > 0) {
					const currentIndex = artistTracks.indexOf(currentRow);
					const nextIndex = (currentIndex + 1) % artistTracks.length;
					playRowWithoutDeactivatingLoop(artistTracks[nextIndex]);
					return;
				}
			}

			if (currentButton) {
				currentButton.textContent = '▶';
				currentRow?.classList.remove('playing');
			}

			// Auto-play: shuffle mode = random, otherwise = sequential
			if (shuffleMode) {
				const nextRow = getRandomUnplayedTrack();
				if (nextRow) {
					playRow(nextRow);
				}
			} else if (currentRow) {
				// Play next track in order
				const allRows = getAllTrackRows();
				const currentIndex = allRows.indexOf(currentRow);
				const nextIndex = (currentIndex + 1) % allRows.length;
				playRow(allRows[nextIndex]);
			}
		});

		// Update button state when audio is paused externally
		audioPlayer.addEventListener('pause', () => {
			if (currentButton && !audioPlayer.ended) {
				currentButton.textContent = '▶';
				currentRow?.classList.remove('playing');
			}
		});

		// Update button state when audio plays
		audioPlayer.addEventListener('play', () => {
			if (currentButton) {
				currentButton.textContent = '❚❚';
				currentRow?.classList.add('playing');
			}
		});

		const downloadLinks = document.querySelectorAll('.size-link');

		// Use the same download flow on all devices:
		// 1) Try service worker-powered proxy for direct downloads
		// 2) Fall back to direct Catbox links if SW isn't available or fails
		if ('serviceWorker' in navigator) {
			// Disable download links until SW is ready
			downloadLinks.forEach(link => {
				link.style.opacity = '0.5';
				link.style.pointerEvents = 'none';
				link.title = 'Preparing downloads...';
			});

			navigator.serviceWorker.register('/download-sw.js')
				.then(registration => {
					console.log('[Download SW] Registered:', registration);
					return navigator.serviceWorker.ready;
				})
				.then(() => {
					console.log('[Download SW] Ready! Downloads enabled.');
					downloadLinks.forEach(link => {
						link.style.opacity = '1';
						link.style.pointerEvents = 'auto';
						link.title = 'Download';
					});
				})
				.catch(error => {
					console.error('[Download SW] Registration failed:', error);
					console.log('[Download SW] Falling back to direct downloads');

					// Fallback: change links to direct Catbox URLs
					downloadLinks.forEach(link => {
						const url = new URL(link.href);
						const fileUrl = url.searchParams.get('url');
						if (fileUrl) {
							link.href = fileUrl;
							link.target = '_blank';
						}
						link.style.opacity = '1';
						link.style.pointerEvents = 'auto';
						link.title = 'Download (opens in new tab)';
					});
				});
		} else {
			// No service worker support - use direct links
			console.log('[Download SW] Service workers not supported');
			downloadLinks.forEach(link => {
				const url = new URL(link.href);
				const fileUrl = url.searchParams.get('url');
				if (fileUrl) {
					link.href = fileUrl;
					link.target = '_blank';
				}
				link.title = 'Download (opens in new tab)';
			});
		}

		// Fix h1 cursor and link behavior (override BlogPost layout JS)
		setTimeout(() => {
			const h1 = document.querySelector('.directory-listing h1');
			if (h1) h1.style.cursor = 'default';

			// Make the Index link work by stopping propagation
			const h1Link = document.querySelector('.directory-listing h1 a');
			if (h1Link) {
				h1Link.addEventListener('click', (e) => {
					e.stopPropagation();
				});
			}
		}, 0);

		// Fetch durations for all tracks
		const formatDuration = (seconds) => {
			const mins = Math.floor(seconds / 60);
			const secs = Math.floor(seconds % 60);
			return `${mins}:${secs.toString().padStart(2, '0')}`;
		};

		document.querySelectorAll('tr.file').forEach(row => {
			const audioSrc = row.getAttribute('data-audio-src');
			const durationCell = row.querySelector('.col-duration');
			if (audioSrc && durationCell) {
				const audio = new Audio();
				audio.preload = 'metadata';
				audio.addEventListener('loadedmetadata', () => {
					durationCell.textContent = formatDuration(audio.duration);
				});
				audio.addEventListener('error', () => {
					durationCell.textContent = '-';
				});
				audio.src = audioSrc;
			}
		});

		// Mini player functionality
		const miniPlayer = document.getElementById('mini-player');
		const miniTrackName = miniPlayer.querySelector('.mini-track-name');
		const miniTrackArtist = miniPlayer.querySelector('.mini-track-artist');
		const miniTrackQueued = miniPlayer.querySelector('.mini-track-queued');
		const miniQueuedName = miniPlayer.querySelector('.queued-name');
		const miniArtistQueued = miniPlayer.querySelector('.mini-artist-queued');
		const miniQueuedArtistName = miniPlayer.querySelector('.queued-artist-name');
		const miniCurrentTime = miniPlayer.querySelector('.mini-current-time');
		const miniDuration = miniPlayer.querySelector('.mini-duration');
		const miniProgressFill = miniPlayer.querySelector('.mini-progress-fill');
		const miniProgressBar = miniPlayer.querySelector('.mini-progress-bar');
		const miniPlayBtn = miniPlayer.querySelector('.mini-play-btn');
		const miniPrevBtn = miniPlayer.querySelector('.mini-prev-btn');
		const miniNextBtn = miniPlayer.querySelector('.mini-next-btn');
		const miniShuffleBtn = miniPlayer.querySelector('.mini-shuffle-btn');
		const miniVolumeSlider = miniPlayer.querySelector('.mini-volume-slider');

		// Volume control
		const updateVolumeVisual = (volume) => {
			const percent = volume * 100;
			miniVolumeSlider.style.setProperty('--volume-fill', `${percent}%`);
		};

		miniVolumeSlider.addEventListener('input', (e) => {
			const volume = e.target.value / 100;
			audioPlayer.volume = volume;
			updateVolumeVisual(volume);
			localStorage.setItem('miniPlayerVolume', volume);
		});

		// Load saved volume
		const savedVolume = localStorage.getItem('miniPlayerVolume');
		if (savedVolume !== null) {
			const vol = parseFloat(savedVolume);
			audioPlayer.volume = vol;
			miniVolumeSlider.value = vol * 100;
			updateVolumeVisual(vol);
		} else {
			updateVolumeVisual(1);
		}

		// Show mini player and update track info when playing
		const updateMiniPlayer = () => {
			if (currentRow) {
				const trackName = currentRow.querySelector('.track-name')?.textContent || '-';
				const trackArtist = currentRow.querySelector('.track-artist')?.textContent || '-';
				miniTrackName.textContent = trackName;
				miniTrackArtist.textContent = trackArtist;
				miniPlayer.classList.remove('hidden');
			}
		};

		// Update progress bar and time
		audioPlayer.addEventListener('timeupdate', () => {
			if (audioPlayer.duration) {
				const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
				miniProgressFill.style.width = progress + '%';
				miniCurrentTime.textContent = formatDuration(audioPlayer.currentTime);
				miniDuration.textContent = formatDuration(audioPlayer.duration);
			}
		});

		// Update mini player when track changes
		audioPlayer.addEventListener('play', updateMiniPlayer);
		audioPlayer.addEventListener('loadedmetadata', () => {
			miniDuration.textContent = formatDuration(audioPlayer.duration);
		});

		// Update mini play button state
		audioPlayer.addEventListener('play', () => {
			miniPlayBtn.textContent = '❚❚';
		});
		audioPlayer.addEventListener('pause', () => {
			miniPlayBtn.textContent = '▶';
		});

		// ========== BROWSER INTEGRATION ==========
		// Document title, Media Session API, and favicon animation

		const originalTitle = document.title;
		const originalFavicon = document.querySelector('link[rel="icon"][sizes="32x32"]')?.href || '/favicons/favicon-32x32.png';
		let faviconAnimationId = null;

		// Strip file extension from track name
		const stripExtension = (filename) => {
			return filename.replace(/\.[^/.]+$/, '');
		};

		// Update document title with current track
		const updateDocumentTitle = (isPlaying) => {
			if (!currentRow || !isPlaying) {
				document.title = originalTitle;
				return;
			}
			const trackName = currentRow.querySelector('.track-name')?.textContent || '';
			const trackArtist = currentRow.querySelector('.track-artist')?.textContent || '';
			const cleanName = stripExtension(trackName);
			document.title = `ely0030 | ${cleanName}`;
		};

		// Media Session API - native OS media controls
		const updateMediaSession = () => {
			if (!('mediaSession' in navigator) || !currentRow) return;

			const trackName = currentRow.querySelector('.track-name')?.textContent || '';
			const trackArtist = currentRow.querySelector('.track-artist')?.textContent || '';
			const cleanName = stripExtension(trackName);

			navigator.mediaSession.metadata = new MediaMetadata({
				title: cleanName,
				artist: trackArtist,
				album: 'ely0030 | Music'
			});

			navigator.mediaSession.setActionHandler('play', () => audioPlayer.play());
			navigator.mediaSession.setActionHandler('pause', () => audioPlayer.pause());
			navigator.mediaSession.setActionHandler('previoustrack', () => miniPrevBtn.click());
			navigator.mediaSession.setActionHandler('nexttrack', () => miniNextBtn.click());
		};

		// Favicon pulse animation when playing
		const faviconCanvas = document.createElement('canvas');
		faviconCanvas.width = 32;
		faviconCanvas.height = 32;
		const faviconCtx = faviconCanvas.getContext('2d');
		const faviconImg = new Image();
		faviconImg.src = originalFavicon;

		let faviconPhase = 0;
		const animateFavicon = () => {
			if (!faviconImg.complete) {
				faviconAnimationId = requestAnimationFrame(animateFavicon);
				return;
			}

			faviconPhase += 0.05;
			const pulse = 0.7 + 0.3 * Math.sin(faviconPhase); // Oscillate between 0.7 and 1.0

			faviconCtx.clearRect(0, 0, 32, 32);
			faviconCtx.globalAlpha = pulse;
			faviconCtx.drawImage(faviconImg, 0, 0, 32, 32);

			const link = document.querySelector('link[rel="icon"][sizes="32x32"]');
			if (link) {
				link.href = faviconCanvas.toDataURL('image/png');
			}

			faviconAnimationId = requestAnimationFrame(animateFavicon);
		};

		const startFaviconAnimation = () => {
			if (!faviconAnimationId) {
				faviconPhase = 0;
				animateFavicon();
			}
		};

		const stopFaviconAnimation = () => {
			if (faviconAnimationId) {
				cancelAnimationFrame(faviconAnimationId);
				faviconAnimationId = null;
				// Restore original favicon
				const link = document.querySelector('link[rel="icon"][sizes="32x32"]');
				if (link) link.href = originalFavicon;
			}
		};

		// Hook into play/pause events
		audioPlayer.addEventListener('play', () => {
			updateDocumentTitle(true);
			updateMediaSession();
			startFaviconAnimation();
		});
		audioPlayer.addEventListener('pause', () => {
			updateDocumentTitle(false);
			stopFaviconAnimation();
		});
		audioPlayer.addEventListener('ended', () => {
			// Don't reset title on ended - next track will update it
			// stopFaviconAnimation handled by pause event
		});

		// Mini player controls
		miniPlayBtn.addEventListener('click', () => {
			if (audioPlayer.paused) {
				audioPlayer.play();
			} else {
				audioPlayer.pause();
			}
		});

		miniNextBtn.addEventListener('click', () => {
			// If there's a queued track (pinned on table), skip to that
			// Validate row still exists in DOM before using
			if (queuedLoopRow && document.contains(queuedLoopRow)) {
				const rowToPlay = queuedLoopRow;
				queuedLoopRow = null;
				hideQueuedTrack();
				playRowWithoutDeactivatingLoop(rowToPlay);
				// Show loop symbol after mini player updates
				setTimeout(() => {
					if (loopMode) {
						const plainName = miniTrackNameEl.textContent;
						miniTrackNameEl.innerHTML = wrapExtension(plainName);
						miniPlayerTrack.classList.add('loop-mode');
					}
				}, 50);
				return;
			} else if (queuedLoopRow) {
				// Row was deleted from DOM - clear stale reference
				queuedLoopRow = null;
				hideQueuedTrack();
			}

			// If there's a queued artist (pinned on table), skip to that artist
			if (queuedLoopArtist) {
				const artistToLoop = queuedLoopArtist.trim();  // Normalize whitespace
				queuedLoopArtist = null;
				hideQueuedTrack();
				// Find first track by this artist
				const allRows = getAllTrackRows();
				const artistTracks = allRows.filter(row => {
					const artistEl = row.querySelector('.track-artist');
					return artistEl && artistEl.textContent.trim() === artistToLoop;
				});
				if (artistTracks.length > 0) {
					playRowWithoutDeactivatingLoop(artistTracks[0]);
					setTimeout(() => {
						activateArtistLoopMode(artistToLoop);
					}, 50);
				}
				return;
			}

			// If in track loop mode, just replay the same track (reset time, don't reload src)
			if (loopMode && currentRow) {
				audioPlayer.currentTime = 0;
				audioPlayer.play();
				return;
			}

			// If in artist loop mode, cycle through that artist's tracks only
			if (artistLoopMode && loopArtist) {
				const allRows = getAllTrackRows();
				const artistTracks = allRows.filter(row => {
					const artistEl = row.querySelector('.track-artist');
					return artistEl && artistEl.textContent.trim() === loopArtist.trim();
				});
				if (artistTracks.length > 0 && currentRow) {
					const currentIndex = artistTracks.indexOf(currentRow);
					const nextIndex = (currentIndex + 1) % artistTracks.length;
					playRowWithoutDeactivatingLoop(artistTracks[nextIndex]);
				}
				return;
			}

			const allRows = getAllTrackRows();
			if (shuffleMode) {
				const nextRow = getRandomUnplayedTrack();
				if (nextRow) playRow(nextRow);
			} else if (currentRow) {
				const currentIndex = allRows.indexOf(currentRow);
				const nextIndex = (currentIndex + 1) % allRows.length;
				playRow(allRows[nextIndex]);
			}
		});

		miniPrevBtn.addEventListener('click', () => {
			// If in track loop mode, just replay the same track
			if (loopMode && currentRow) {
				audioPlayer.currentTime = 0;
				audioPlayer.play();
				return;
			}

			// If in artist loop mode, cycle through that artist's tracks only
			if (artistLoopMode && loopArtist) {
				const allRows = getAllTrackRows();
				const artistTracks = allRows.filter(row => {
					const artistEl = row.querySelector('.track-artist');
					return artistEl && artistEl.textContent.trim() === loopArtist.trim();
				});
				if (artistTracks.length > 0 && currentRow) {
					const currentIndex = artistTracks.indexOf(currentRow);
					const prevIndex = (currentIndex - 1 + artistTracks.length) % artistTracks.length;
					playRowWithoutDeactivatingLoop(artistTracks[prevIndex]);
				}
				return;
			}

			// Normal prev - go to previous track globally
			const allRows = getAllTrackRows();
			if (currentRow) {
				const currentIndex = allRows.indexOf(currentRow);
				const prevIndex = (currentIndex - 1 + allRows.length) % allRows.length;
				playRow(allRows[prevIndex]);
			}
		});

		miniShuffleBtn.addEventListener('click', () => {
			shuffleMode = !shuffleMode;
			miniShuffleBtn.classList.toggle('active', shuffleMode);
		});

		// Seek via progress bar (click)
		miniProgressBar.addEventListener('click', (e) => {
			const rect = miniProgressBar.getBoundingClientRect();
			const percent = (e.clientX - rect.left) / rect.width;
			audioPlayer.currentTime = percent * audioPlayer.duration;
		});

		// Seek via progress bar (touch scrubbing)
		let isScrubbing = false;
		const seekToTouch = (e) => {
			const rect = miniProgressBar.getBoundingClientRect();
			const touch = e.touches[0];
			const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
			audioPlayer.currentTime = percent * audioPlayer.duration;
		};

		miniProgressBar.addEventListener('touchstart', (e) => {
			isScrubbing = true;
			seekToTouch(e);
		}, { passive: true });

		document.addEventListener('touchmove', (e) => {
			if (isScrubbing && e.touches.length === 1) {
				seekToTouch(e);
			}
		}, { passive: true });

		document.addEventListener('touchend', () => {
			isScrubbing = false;
		});

		// Handle interrupted touches (incoming call, gesture conflict, etc.)
		document.addEventListener('touchcancel', () => {
			isScrubbing = false;
		});

		// Pin state - always starts pinned
		let isPinned = false;

		// Loop mode - activated by dropping pin on track name
		let loopMode = false;
		let loopPinOffsetX = 0;  // Pin offset from card left edge when in loop mode
		let loopPinOffsetY = 0;  // Pin offset from card top edge when in loop mode

		// Artist loop mode - activated by dropping pin on artist name
		let artistLoopMode = false;
		let loopArtist = '';  // The artist name to loop

		// Pin on table mode - when pin is tacked to table row instead of mini player
		let pinOnTable = false;
		let pinnedTableElement = null;  // The table element where pin is tacked
		let queuedLoopRow = null;  // Track row queued to play next (when pinning a different track on table)
		let queuedLoopArtist = null;  // Artist name queued for artist loop (when pinning a different artist on table)

		// Mini player drag functionality with physics
		let isDragging = false;
		let dragOffsetX = 0;
		let dragOffsetY = 0;

		// Physics state
		let velocityX = 0;
		let velocityY = 0;
		let lastX = 0;
		let lastY = 0;
		let lastTime = 0;
		let animationId = null;

		// Physics constants - sticky with superconductor glide on hard throws
		const FRICTION = 0.98;          // Low friction once moving
		const MIN_VELOCITY = 0.1;       // Stop at very low speed for smooth settle
		const BOUNCE_DAMPING = 0.5;     // Moderate bounce
		const VELOCITY_SCALE = 1.0;     // Direct throw response
		const THROW_THRESHOLD = 8;      // Must exceed this velocity to glide (sticky otherwise)

		// ========== AUTONOMOUS PIN ==========
		// The pin is its own entity - it just wants to be on the card
		// When the card moves, pin decides whether to follow or give up

		const autonomousPin = document.getElementById('autonomous-pin');
		const pinHead = autonomousPin.querySelector('.pin-head');
		const pinNeedle = autonomousPin.querySelector('.pin-needle');

		// Touch loupe for mobile
		const touchLoupe = document.getElementById('touch-loupe');
		const loupeViewport = touchLoupe?.querySelector('.loupe-viewport');
		const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

		// Pin state
		let pinX = 0;
		let pinY = 0;
		let pinGaveUp = false;
		let pinIsRunning = false;
		let pinIsLifted = false;  // Track if user is holding/dragging the card
		let pinAnimationId = null;
		let currentCardSpeed = 0; // Track how fast the card is moving
		let lastPinDistance = 0;  // Track distance to detect card approaching
		let pinVelX = 0;          // Smoothed velocity for anti-jitter
		let pinVelY = 0;
		let pinReturningFromTable = false;  // Flag to prevent chase logic during return animation
		let pinWaitingForSlowdown = false;  // Pin came from table, waiting for card to slow down
		let pinMadeAttempt = false;         // Pin made initial attempt before deciding to wait
		let pinRunLoopActive = false;       // Prevent multiple runLoop instances

		// Pin personality
		const PIN_GIVEUP_SPEED = 6;     // Card speed where pin gives up chasing hard
		const PIN_RUN_SPEED = 0.15;     // How fast pin catches up (ratio per frame)
		const PIN_LAZY_SPEED = 0.03;    // Slower chase when "gave up" (still follows, just lazily)
		const PIN_WAIT_DISTANCE = 350;  // Distance where asymptotic slowdown kicks in strongly
		const PIN_REPULSION = 1.2;      // How much pin backs away when card rushes at it

		// Get where the pin wants to be (on the card) - tack spot
		// Returns document coords when pinned, viewport coords otherwise
		const getPinTargetPosition = () => {
			const cardRect = miniPlayer.getBoundingClientRect();

			if (isPinned) {
				// Use style properties directly for consistent document coordinates
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				return {
					x: cardDocX + cardRect.width - 25,
					y: cardDocY + 8
				};
			}
			// Viewport coordinates for fixed positioning
			return {
				x: cardRect.right - 25,
				y: cardRect.top + 8
			};
		};

		// Get center of mini player - for repulsion field
		// Returns document coords when pinned, viewport coords otherwise
		const getCardCenter = () => {
			const cardRect = miniPlayer.getBoundingClientRect();

			if (isPinned) {
				// Use style properties directly for consistent document coordinates
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				return {
					x: cardDocX + cardRect.width / 2,
					y: cardDocY + cardRect.height / 2
				};
			}
			// Viewport coordinates for fixed positioning
			return {
				x: cardRect.left + cardRect.width / 2,
				y: cardRect.top + cardRect.height / 2
			};
		};

		// Update pin position and visuals
		const updateAutonomousPin = () => {
			if (!isPinned) {
				autonomousPin.classList.add('hidden');
				return;
			}
			// Don't interfere if pin is doing its own return animation from table
			if (pinReturningFromTable) return;

			autonomousPin.classList.remove('hidden');

			// Use loop position if in any loop mode, otherwise standard tack position
			const target = (loopMode || artistLoopMode) ? getLoopPinPosition() : getPinTargetPosition();
			const dx = target.x - pinX;
			const dy = target.y - pinY;
			const distance = Math.sqrt(dx * dx + dy * dy);

			// Use card CENTER for repulsion field (not tack spot)
			const center = getCardCenter();
			const cdx = center.x - pinX;
			const cdy = center.y - pinY;
			const centerDistance = Math.sqrt(cdx * cdx + cdy * cdy);

			// Detect if card center is approaching
			const approachSpeed = lastPinDistance - centerDistance; // positive = card approaching
			lastPinDistance = centerDistance;

			// Gentle repulsion field - centered on entire mini player
			// Wide, smooth effect - not jerky
			let repulsion = 0;
			if (approachSpeed > 0 && centerDistance < PIN_WAIT_DISTANCE && !pinIsRunning) {
				// Smooth falloff based on distance from center
				const distanceRatio = 1 - (centerDistance / PIN_WAIT_DISTANCE);
				// Scale gently with approach speed
				const approachFactor = Math.min(approachSpeed / 8, 1);
				// Gentle repulsion force
				repulsion = PIN_REPULSION * distanceRatio * approachFactor * 0.5;
			}

			// Proximity repulsion - back off if too close to card center
			let moveX = 0;
			let moveY = 0;

			const MIN_COMFORT_DISTANCE = 120;
			if (centerDistance < MIN_COMFORT_DISTANCE && !pinIsRunning) {
				const tooClose = 1 - (centerDistance / MIN_COMFORT_DISTANCE);
				const lowInertiaFactor = 1 - Math.min(1, currentCardSpeed / 3);
				const backoffStrength = tooClose * lowInertiaFactor * 4;

				// Back away from card center
				if (centerDistance > 0) {
					moveX -= (cdx / centerDistance) * backoffStrength;
					moveY -= (cdy / centerDistance) * backoffStrength;
				}
			}

			if (pinIsRunning) {
				// Running to catch up (after card stopped) - no slowdown, full speed
				const speed = PIN_RUN_SPEED + (distance / 500);
				pinX += dx * Math.min(speed, 0.3);
				pinY += dy * Math.min(speed, 0.3);

				if (distance < 3) {
					pinX = target.x;
					pinY = target.y;
					pinIsRunning = false;

					// Pin tacking animation - needle shrinks as it enters
					autonomousPin.classList.add('tacking');
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';

					// Card impact animation - add BEFORE removing gliding so animation controls shadow
					miniPlayer.classList.add('just-pinned');

					// Cleanup after animation (200ms to match CSS animation duration)
					setTimeout(() => {
						autonomousPin.classList.remove('tacking');
						autonomousPin.classList.add('resting');
						pinHead.style.transform = '';
						pinNeedle.style.transform = '';
						pinNeedle.style.transition = '';
						miniPlayer.classList.remove('just-pinned', 'gliding', 'dragging');
					}, 200);
				}
			} else {
				// Check if pin is waiting for card to stop (came from table while card was moving)
				// Don't clear this flag here - let onCardStopped() handle it to avoid race condition
				if (pinWaitingForSlowdown) {
					// Card still in motion OR waiting for onCardStopped to be called
					if (!pinMadeAttempt) {
						// Make one attempt toward the target, then wait
						const target = getPinTargetPosition();
						const dx = target.x - pinX;
						const dy = target.y - pinY;
						const dist = Math.sqrt(dx * dx + dy * dy);
						if (dist > 0) {
							pinVelX = (dx / dist) * 1.5;
							pinVelY = (dy / dist) * 1.5;
						}
						pinMadeAttempt = true;
					} else {
						// Just coast to a stop - no random drift
						pinVelX *= 0.92;
						pinVelY *= 0.92;
					}

					pinX += pinVelX;
					pinY += pinVelY;

					// Position and skip the rest of chase logic
					autonomousPin.style.left = pinX + 'px';
					autonomousPin.style.top = pinY + 'px';
					return;
				}

				// Normal chase with asymptotic slowdown
				const speedFactor = Math.min(1, currentCardSpeed / PIN_GIVEUP_SPEED);
				const distanceFactor = Math.min(1, distance / PIN_WAIT_DISTANCE);

				// When card is slow, go super asymptotic - pin knows tack animation will handle it
				// Square the speed factor to make low speeds even more dramatic
				const adjustedSpeedFactor = speedFactor * speedFactor;

				// When card has high inertia, weaken the distance-based slowdown
				// Pin chases more actively when card is moving fast
				const adjustedDistanceFactor = distanceFactor + (1 - distanceFactor) * speedFactor;

				// IMMENSE slowdown when both inertia AND distance are low
				// Pin knows: "card is almost stopped and I'm close - tack will handle it"
				const lowInertia = 1 - speedFactor; // high when card slow
				const closeDistance = 1 - distanceFactor; // high when pin close
				const immensifier = 1 - (lowInertia * closeDistance * 0.95); // approaches 0.05 when both max

				const urgency = Math.max(0.005, adjustedSpeedFactor * 0.5 + adjustedDistanceFactor * 0.5) * immensifier;

				const baseSpeed = pinGaveUp ? PIN_LAZY_SPEED : PIN_RUN_SPEED;
				const finalSpeed = baseSpeed * urgency;

				// Apply chase movement minus gentle repulsion
				const effectiveSpeed = Math.max(0, finalSpeed - repulsion);
				moveX += dx * effectiveSpeed;
				moveY += dy * effectiveSpeed;

				// If repulsion is strong enough, also back away a tiny bit
				if (repulsion > finalSpeed && distance > 0) {
					const backoff = (repulsion - finalSpeed) * 0.3;
					moveX -= (dx / distance) * backoff;
					moveY -= (dy / distance) * backoff;
				}

				// Smooth the movement to reduce jitter
				pinVelX = pinVelX * 0.7 + moveX * 0.3;
				pinVelY = pinVelY * 0.7 + moveY * 0.3;
				pinX += pinVelX;
				pinY += pinVelY;
			}

			// Position the pin
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// Visual styling - static lifted state while chasing
			// Stay lifted if user is holding the card OR if distance > 8
			if (pinIsLifted || distance > 8) {
				// Chasing/holding - static lifted look
				autonomousPin.classList.remove('gave-up', 'resting');
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = pinGaveUp ? '0.7' : '1';

				if (pinGaveUp) {
					autonomousPin.classList.add('gave-up');
				}
			} else {
				// Resting on card
				autonomousPin.classList.remove('gave-up');
				autonomousPin.classList.add('resting');
				pinHead.style.transform = '';
				pinNeedle.style.transform = '';
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';
			}
		};

		// Called when card starts moving - pin gets pulled up with resistance feel
		const onCardStartMoving = () => {
			if (!isPinned) return;

			// Check if pin is already lifted/chasing (grabbed mid-flight)
			const alreadyChasing = pinIsLifted || !autonomousPin.classList.contains('resting');

			// Reset state for new movement
			currentCardSpeed = 10; // Assume fast initially
			pinGaveUp = false;
			pinIsLifted = true;  // Pin is being held up!
			pinIsRunning = false; // Stop any chase in progress (runLoop will self-terminate)
			pinWaitingForSlowdown = false; // Clear waiting state
			pinMadeAttempt = false;

			// Hide loop icon while pin is in flight (will restore when pin tacks)
			// Also restore plain text for track name (removes extension span)
			if (loopMode) {
				miniTrackNameEl.textContent = getPlainTrackName();
			}
			miniPlayerTrack.classList.remove('loop-mode', 'artist-loop-mode');

			// Also remove highlight from page artist names while pin is floating
			// (they'll be restored when pin re-tacks if still in artist loop mode)
			if (artistLoopMode) {
				const allArtists = document.querySelectorAll('tr.file .track-artist.pinned-loop');
				allArtists.forEach(el => el.classList.remove('pinned-loop'));
			}

			if (alreadyChasing) {
				// Pin is already in the air - just continue chasing from current position
				// Don't reset position, just ensure it's in lifted visual state
				autonomousPin.classList.remove('hidden', 'resting', 'gave-up');
				autonomousPin.style.transition = '';
				pinNeedle.style.transition = '';
				pinHead.style.transition = '';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				return;
			}

			// Use loop position if in any loop mode, otherwise standard tack position
			const target = (loopMode || artistLoopMode) ? getLoopPinPosition() : getPinTargetPosition();

			// Start pin at tack position with needle hidden (resting state)
			autonomousPin.style.transition = 'none';
			pinX = target.x;
			pinY = target.y;
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// Start with needle hidden, will emerge as pin is pulled
			autonomousPin.classList.remove('hidden', 'resting', 'gave-up');
			pinNeedle.style.transition = 'none';
			pinNeedle.style.height = '0';
			pinNeedle.style.opacity = '0';
			pinHead.style.transform = '';
			pinNeedle.style.transform = '';

			// Force reflow
			autonomousPin.offsetHeight;

			// Animate the pull-up: needle emerges + pin lifts + rotates
			const pullDuration = 100; // ms
			autonomousPin.style.transition = `left ${pullDuration}ms ease-out, top ${pullDuration}ms ease-out`;
			pinNeedle.style.transition = `height ${pullDuration}ms ease-out, opacity ${pullDuration}ms ease-out`;
			pinHead.style.transition = `transform ${pullDuration}ms ease-out`;

			// Needle emerges
			pinNeedle.style.height = '15px';
			pinNeedle.style.opacity = '1';
			pinHead.style.transform = 'rotate(15deg)';
			pinNeedle.style.transform = 'rotate(15deg)';

			// Pin lifts up and slightly to the side
			const liftOffsetX = 8;
			const liftOffsetY = -20;
			pinX = target.x + liftOffsetX;
			pinY = target.y + liftOffsetY;
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// Clear transitions after pull-up completes
			setTimeout(() => {
				autonomousPin.style.transition = '';
				pinNeedle.style.transition = '';
				pinHead.style.transition = '';
			}, pullDuration);
		};

		// Called each frame while card is moving
		const onCardMoving = (speed) => {
			if (!isPinned) return;

			// Track current card speed so pin can make smart decisions
			currentCardSpeed = speed;

			if (speed > PIN_GIVEUP_SPEED && !pinGaveUp) {
				// Card is too fast - give up!
				pinGaveUp = true;
				pinIsRunning = false;
			}

			// If card starts moving again while pin was chasing (running mode),
			// and card is fast, go back to waiting/lazy mode
			if (pinIsRunning && speed > PIN_GIVEUP_SPEED * 0.5) {
				pinIsRunning = false;
				pinWaitingForSlowdown = true;
				pinMadeAttempt = true; // Skip initial attempt since already moving
				pinGaveUp = true;
			}

			updateAutonomousPin();
		};

		// Called when card fully stops - pin flies to card and tacks in
		const onCardStopped = () => {
			if (!isPinned) return;
			// Don't interfere if pin is doing its own return animation from table
			if (pinReturningFromTable) return;

			// If pin was waiting/meandering, let it chase first instead of instant tack
			const wasWaiting = pinWaitingForSlowdown;

			pinGaveUp = false;
			pinWaitingForSlowdown = false;  // Clear waiting state
			pinMadeAttempt = false;
			pinIsLifted = false;  // No longer being held
			currentCardSpeed = 0;

			if (wasWaiting) {
				// Pin was meandering - trigger running mode to chase, then tack when close
				pinIsRunning = true;
				// Reset velocity from meander drift for clean chase
				pinVelX = 0;
				pinVelY = 0;
				// Card should look elevated (lifted) while pin approaches
				miniPlayer.classList.add('gliding');
				// Start animation loop since card is no longer moving (onCardMoving won't be called)
				// Guard against multiple runLoop instances
				if (!pinRunLoopActive) {
					pinRunLoopActive = true;
					const runLoop = () => {
						if (pinIsRunning) {
							updateAutonomousPin();
							requestAnimationFrame(runLoop);
						} else {
							pinRunLoopActive = false;
						}
					};
					requestAnimationFrame(runLoop);
				}
				return;
			}

			pinIsRunning = false;

			// Use loop position if in any loop mode, otherwise normal tack position
			const target = (loopMode || artistLoopMode) ? getLoopPinPosition() : getPinTargetPosition();

			// Calculate how far the pin needs to travel
			const dx = target.x - pinX;
			const dy = target.y - pinY;
			const distance = Math.sqrt(dx * dx + dy * dy);

			// Dart-throw snap to target - duration scales with distance (min 80ms, max 200ms)
			const travelTime = Math.min(200, Math.max(80, distance * 0.8));

			// Keep needle visible during flight - ensure it's in lifted state
			autonomousPin.classList.remove('gave-up', 'resting');
			pinNeedle.style.transition = 'none';
			pinNeedle.style.height = '15px';
			pinNeedle.style.opacity = '1';
			pinHead.style.transform = 'rotate(15deg)';
			pinNeedle.style.transform = 'rotate(15deg)';

			// Animate pin flying to target
			autonomousPin.style.transition = `left ${travelTime}ms cubic-bezier(0.2, 0, 0.2, 1), top ${travelTime}ms cubic-bezier(0.2, 0, 0.2, 1)`;
			pinX = target.x;
			pinY = target.y;
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// After pin arrives at target, play tacking + card impact SIMULTANEOUSLY
			setTimeout(() => {
				autonomousPin.style.transition = '';

				// Pin tacking animation - needle shrinks as it enters
				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				// Card impact animation - starts at SAME TIME as pin tacking
				miniPlayer.classList.add('just-pinned');

				// After both animations complete (200ms), clean up
				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					pinNeedle.style.transition = '';
					miniPlayer.classList.remove('just-pinned', 'gliding');

					// Restore loop icon now that pin is tacked
					if (loopMode) {
						// Re-wrap extension for proper coloring
						const plainName = getPlainTrackName();
						miniTrackNameEl.innerHTML = wrapExtension(plainName);
						miniPlayerTrack.classList.add('loop-mode');
					} else if (artistLoopMode) {
						miniPlayerTrack.classList.add('artist-loop-mode');
						// Also restore highlight on ALL matching page artist names
						const allArtists = document.querySelectorAll('tr.file .track-artist');
						allArtists.forEach(el => {
							if (el.textContent === loopArtist) {
								el.classList.add('pinned-loop');
							}
						});
					}
				}, 200);
			}, travelTime);
		};

		// Legacy function name for compatibility
		const updatePinTrailing = (vx, vy) => {
			const speed = Math.sqrt(vx * vx + vy * vy);
			onCardMoving(speed);
		};

		const triggerPinImpact = () => {
			onCardStopped();
		};

		// Get current position
		// Returns document coords when pinned, viewport coords otherwise
		const getPosition = () => {
			const rect = miniPlayer.getBoundingClientRect();
			if (isPinned) {
				// Document coordinates for absolute positioning
				return {
					x: rect.left + window.scrollX,
					y: rect.top + window.scrollY
				};
			}
			return { x: rect.left, y: rect.top };
		};

		// Set position with bounds checking
		const setPosition = (x, y, bounce = false) => {
			const maxX = window.innerWidth - miniPlayer.offsetWidth;
			let maxY, minY;

			if (isPinned) {
				// Page bounds when pinned
				minY = 0;
				maxY = document.documentElement.scrollHeight - miniPlayer.offsetHeight;
			} else {
				// Viewport bounds when not pinned
				minY = 0;
				maxY = window.innerHeight - miniPlayer.offsetHeight;
			}

			let bounced = false;

			// Bounce off horizontal edges
			if (x < 0) {
				x = 0;
				if (bounce) { velocityX = -velocityX * BOUNCE_DAMPING; bounced = true; }
			} else if (x > maxX) {
				x = maxX;
				if (bounce) { velocityX = -velocityX * BOUNCE_DAMPING; bounced = true; }
			}

			// Bounce off vertical edges
			if (y < minY) {
				y = minY;
				if (bounce) { velocityY = -velocityY * BOUNCE_DAMPING; bounced = true; }
			} else if (y > maxY) {
				y = maxY;
				if (bounce) { velocityY = -velocityY * BOUNCE_DAMPING; bounced = true; }
			}

			miniPlayer.style.bottom = 'auto';
			miniPlayer.style.right = 'auto';
			miniPlayer.style.left = x + 'px';
			miniPlayer.style.top = y + 'px';
			miniPlayer.classList.add('dragged');

			return bounced;
		};

		// Ensure mini player is within reachable bounds (can be scrolled to)
		const ensureInReachableBounds = () => {
			if (!isPinned) return;

			const pos = getPosition();
			const playerHeight = miniPlayer.offsetHeight;
			const playerWidth = miniPlayer.offsetWidth;

			// Check if player is beyond what user can scroll to
			// For Y: player should be within document content area
			const maxReachableY = document.documentElement.scrollHeight - playerHeight;
			const maxReachableX = window.innerWidth - playerWidth;

			let needsCorrection = false;
			let newX = pos.x;
			let newY = pos.y;

			if (pos.y > maxReachableY) {
				newY = maxReachableY;
				needsCorrection = true;
			}
			if (pos.x > maxReachableX) {
				newX = maxReachableX;
				needsCorrection = true;
			}
			if (pos.x < 0) {
				newX = 0;
				needsCorrection = true;
			}
			if (pos.y < 0) {
				newY = 0;
				needsCorrection = true;
			}

			if (needsCorrection) {
				// Smoothly animate back into bounds
				miniPlayer.style.transition = 'left 0.3s ease-out, top 0.3s ease-out';
				miniPlayer.style.left = newX + 'px';
				miniPlayer.style.top = newY + 'px';
				setTimeout(() => {
					miniPlayer.style.transition = '';
					savePosition();
				}, 300);
			}
		};

		// Animate with inertia
		const animateInertia = () => {
			const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);

			if (speed < MIN_VELOCITY) {
				animationId = null;
				// For pinned mode, keep gliding shadow until impact animation
				// For unpinned mode, remove it now
				if (!isPinned) {
					miniPlayer.classList.remove('gliding');
				}
				triggerPinImpact();
				savePosition();
				// Check if player ended up outside reachable bounds
				ensureInReachableBounds();
				return;
			}

			// Update pin trailing behavior based on velocity
			updatePinTrailing(velocityX, velocityY);

			const pos = getPosition();
			setPosition(pos.x + velocityX, pos.y + velocityY, true);

			// Apply friction
			velocityX *= FRICTION;
			velocityY *= FRICTION;

			animationId = requestAnimationFrame(animateInertia);
		};

		// Stop any ongoing animation
		const stopAnimation = () => {
			if (animationId) {
				cancelAnimationFrame(animationId);
				animationId = null;
				miniPlayer.classList.remove('gliding');
			}
			if (pinAnimationId) {
				cancelAnimationFrame(pinAnimationId);
				pinAnimationId = null;
			}
		};

		// Animate pin drop and tack (shared helper)
		// isSpawn: true when this is the initial spawn (skip impact animation)
		const animatePinTack = (isSpawn = false) => {
			const target = getPinTargetPosition();

			// Start pin above the card for drop-in animation
			const dropHeight = 40;
			pinX = target.x + 8;
			pinY = target.y - dropHeight;
			pinGaveUp = false;
			pinIsRunning = false;
			pinIsLifted = false;

			// Show pin in lifted state (needle visible)
			autonomousPin.classList.remove('hidden', 'resting', 'gave-up', 'tacked');
			autonomousPin.style.transition = 'none';
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';
			pinNeedle.style.height = '15px';
			pinNeedle.style.opacity = '1';
			pinHead.style.transform = 'rotate(15deg)';
			pinNeedle.style.transform = 'rotate(15deg)';

			// Force reflow
			autonomousPin.offsetHeight;

			// Animate pin dropping to tack spot
			const travelTime = 120;
			autonomousPin.style.transition = `left ${travelTime}ms cubic-bezier(0.2, 0, 0.2, 1), top ${travelTime}ms cubic-bezier(0.2, 0, 0.2, 1)`;
			pinX = target.x;
			pinY = target.y;
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// After pin lands, play tacking + card impact SIMULTANEOUSLY
			setTimeout(() => {
				autonomousPin.style.transition = '';

				// Pin tacking animation - needle shrinks as it enters
				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				// Card impact animation - only if card was elevated (not spawning)
				// Spawning cards are already flat, so impact animation would flash
				if (!isSpawn) {
					miniPlayer.classList.add('just-pinned');
				}

				// After both animations complete (200ms), clean up
				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned', 'gliding');
					// Re-enable transitions and shadow now that spawn/tack is complete
					miniPlayer.style.transition = '';
					miniPlayer.style.boxShadow = '';
				}, 200);
			}, travelTime);
		};

		// Spawn mini player pinned next to the currently playing track
		const spawnNextToTrack = () => {
			if (!currentRow) return;

			const rowRect = currentRow.getBoundingClientRect();
			const playerWidth = miniPlayer.offsetWidth;
			const playerHeight = miniPlayer.offsetHeight;

			// Position to the right of the track row, vertically centered
			let x = rowRect.right + 20;  // 20px gap from track row
			let y = rowRect.top + (rowRect.height / 2) - (playerHeight / 2);

			// If not enough room on the right, try the left
			if (x + playerWidth > window.innerWidth - 20) {
				x = rowRect.left - playerWidth - 20;
			}

			// Clamp to viewport bounds
			x = Math.max(20, Math.min(x, window.innerWidth - playerWidth - 20));
			y = Math.max(20, Math.min(y, window.innerHeight - playerHeight - 20));

			// Convert to document coordinates for pinned positioning
			const docX = x + window.scrollX;
			const docY = y + window.scrollY;

			// Set up as pinned - spawn flat immediately (no shadow)
			isPinned = true;

			// Spawn with no shadow, no transitions
			miniPlayer.style.transition = 'none';
			miniPlayer.style.boxShadow = 'none';
			miniPlayer.classList.add('pinned', 'dragged');
			autonomousPin.classList.add('pinned');

			miniPlayer.style.bottom = 'auto';
			miniPlayer.style.right = 'auto';
			miniPlayer.style.left = docX + 'px';
			miniPlayer.style.top = docY + 'px';

			// Force reflow to apply styles without transition
			miniPlayer.offsetHeight;

			// Animate pin tack (isSpawn=true skips impact animation)
			animatePinTack(true);
			savePosition();
		};

		// Always spawn next to the clicked track on first show
		const loadSavedPosition = () => {
			// Always spawn next to the currently playing track
			spawnNextToTrack();
		};

		// Save position to localStorage
		const savePosition = () => {
			const pos = getPosition();
			localStorage.setItem('miniPlayerPos', JSON.stringify({ x: pos.x, y: pos.y, pinned: isPinned }));
		};

		// Start dragging (mouse)
		miniPlayer.addEventListener('mousedown', (e) => {
			if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
				e.target.closest('.mini-progress-bar')) {
				return;
			}

			stopAnimation();
			isDragging = true;
			miniPlayer.classList.add('dragging');

			const rect = miniPlayer.getBoundingClientRect();
			dragOffsetX = e.clientX - rect.left;
			dragOffsetY = e.clientY - rect.top;

			// Initialize velocity tracking
			lastX = e.clientX;
			lastY = e.clientY;
			lastTime = performance.now();
			velocityX = 0;
			velocityY = 0;

			// Initialize autonomous pin
			onCardStartMoving();

			e.preventDefault();
		});

		// Drag move (mouse)
		document.addEventListener('mousemove', (e) => {
			if (!isDragging) return;

			const now = performance.now();
			const dt = now - lastTime;

			// Track velocity (pixels per frame at ~60fps)
			if (dt > 0) {
				const instantVelX = (e.clientX - lastX) / (dt / 16.67);
				const instantVelY = (e.clientY - lastY) / (dt / 16.67);
				// Smooth velocity with exponential moving average
				velocityX = velocityX * 0.7 + instantVelX * 0.3;
				velocityY = velocityY * 0.7 + instantVelY * 0.3;
			}

			lastX = e.clientX;
			lastY = e.clientY;
			lastTime = now;

			// Calculate position - add scroll offset for pinned mode (absolute positioning)
			let newX = e.clientX - dragOffsetX;
			let newY = e.clientY - dragOffsetY;
			if (isPinned) {
				newX += window.scrollX;
				newY += window.scrollY;
			}
			setPosition(newX, newY);

			// Update pin trailing while dragging
			updatePinTrailing(velocityX, velocityY);
		});

		// Stop dragging (mouse)
		document.addEventListener('mouseup', () => {
			if (isDragging) {
				isDragging = false;
				miniPlayer.classList.remove('dragging');

				// Apply velocity scale
				velocityX *= VELOCITY_SCALE;
				velocityY *= VELOCITY_SCALE;

				// Check if throw exceeds threshold (sticky behavior)
				const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
				if (speed > THROW_THRESHOLD) {
					// Real throw - glide with inertia
					miniPlayer.classList.add('gliding');
					animateInertia();
				} else {
					// Small movement - just stop (sticky)
					// For pinned cards, keep elevated shadow until pin tacks in
					if (isPinned) {
						miniPlayer.classList.add('gliding');
					}
					triggerPinImpact();
					savePosition();
				}
			}
		});

		// Touch support
		miniPlayer.addEventListener('touchstart', (e) => {
			if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
				e.target.closest('.mini-progress-bar')) {
				return;
			}

			stopAnimation();
			isDragging = true;
			miniPlayer.classList.add('dragging');

			const rect = miniPlayer.getBoundingClientRect();
			const touch = e.touches[0];
			dragOffsetX = touch.clientX - rect.left;
			dragOffsetY = touch.clientY - rect.top;

			lastX = touch.clientX;
			lastY = touch.clientY;
			lastTime = performance.now();
			velocityX = 0;
			velocityY = 0;

			// Initialize autonomous pin
			onCardStartMoving();
		}, { passive: true });

		document.addEventListener('touchmove', (e) => {
			if (!isDragging) return;
			if (!e.touches.length) return;  // Guard against no touches

			const touch = e.touches[0];
			const now = performance.now();
			const dt = now - lastTime;

			if (dt > 0) {
				const instantVelX = (touch.clientX - lastX) / (dt / 16.67);
				const instantVelY = (touch.clientY - lastY) / (dt / 16.67);
				velocityX = velocityX * 0.7 + instantVelX * 0.3;
				velocityY = velocityY * 0.7 + instantVelY * 0.3;
			}

			lastX = touch.clientX;
			lastY = touch.clientY;
			lastTime = now;

			// Calculate position - add scroll offset for pinned mode (absolute positioning)
			let newX = touch.clientX - dragOffsetX;
			let newY = touch.clientY - dragOffsetY;
			if (isPinned) {
				newX += window.scrollX;
				newY += window.scrollY;
			}
			setPosition(newX, newY);

			// Update pin trailing while dragging
			updatePinTrailing(velocityX, velocityY);
		}, { passive: true });

		document.addEventListener('touchend', () => {
			if (isDragging) {
				isDragging = false;
				miniPlayer.classList.remove('dragging');

				velocityX *= VELOCITY_SCALE;
				velocityY *= VELOCITY_SCALE;

				// Check if throw exceeds threshold (sticky behavior)
				const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
				if (speed > THROW_THRESHOLD) {
					miniPlayer.classList.add('gliding');
					animateInertia();
				} else {
					// For pinned cards, keep elevated shadow until pin tacks in
					if (isPinned) {
						miniPlayer.classList.add('gliding');
					}
					triggerPinImpact();
					savePosition();
				}
			}
		});

		// Handle interrupted mini player drag (incoming call, gesture conflict, etc.)
		document.addEventListener('touchcancel', () => {
			if (isDragging) {
				isDragging = false;
				miniPlayer.classList.remove('dragging');
				// No momentum on cancel - just settle in place
				triggerPinImpact();
				savePosition();
			}
		});

		// Check if point is over or near the mini player (generous hit area)
		const isOverMiniPlayer = (x, y) => {
			const rect = miniPlayer.getBoundingClientRect();
			const viewX = x - window.scrollX;
			const viewY = y - window.scrollY;

			// Add generous padding around the mini player for easier targeting
			const padding = 40;
			return (
				viewX >= rect.left - padding && viewX <= rect.right + padding &&
				viewY >= rect.top - padding && viewY <= rect.bottom + padding
			);
		};

		// Check if point is over the track name text (for loop mode activation)
		const miniPlayerTrack = miniPlayer.querySelector('.mini-player-track');
		const miniTrackNameEl = miniPlayer.querySelector('.mini-track-name');
		const miniTrackArtistEl = miniPlayer.querySelector('.mini-track-artist');

		// Get actual text width (not container width)
		const getTextWidth = (element) => {
			const text = element.textContent;
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			const style = getComputedStyle(element);
			ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
			return ctx.measureText(text).width;
		};

		const isOverTrackName = (x, y) => {
			const rect = miniTrackNameEl.getBoundingClientRect();
			const viewX = x - window.scrollX;
			const viewY = y - window.scrollY;

			// Get actual text width
			const textWidth = Math.min(getTextWidth(miniTrackNameEl), rect.width);

			// Padding: generous on left for easy targeting, minimal on right to avoid empty space
			const paddingLeft = 8;
			const paddingRight = 2;  // Tight right edge - don't include loop icon area
			const paddingTop = 12;
			const paddingBottom = 2;  // Minimal bottom padding to avoid overlap with artist
			return (
				viewX >= rect.left - paddingLeft && viewX <= rect.left + textWidth + paddingRight &&
				viewY >= rect.top - paddingTop && viewY <= rect.bottom + paddingBottom
			);
		};

		// Check if point is over the artist name text (for artist loop mode)
		const isOverArtistName = (x, y) => {
			const rect = miniTrackArtistEl.getBoundingClientRect();
			const viewX = x - window.scrollX;
			const viewY = y - window.scrollY;

			// Get actual text width
			const textWidth = Math.min(getTextWidth(miniTrackArtistEl), rect.width);

			// Padding: generous on left for easy targeting, minimal on right to avoid empty space
			const paddingLeft = 8;
			const paddingRight = 2;  // Tight right edge - don't include loop icon area
			const paddingTop = 2;  // Minimal top padding to avoid overlap with track name
			const paddingBottom = 10;
			return (
				viewX >= rect.left - paddingLeft && viewX <= rect.left + textWidth + paddingRight &&
				viewY >= rect.top - paddingTop && viewY <= rect.bottom + paddingBottom
			);
		};

		// Check if point is over any track name in the main table
		const isOverTableTrackName = (x, y) => {
			const viewX = x - window.scrollX;
			const viewY = y - window.scrollY;
			const trackNames = document.querySelectorAll('tr.file .track-name');

			for (const el of trackNames) {
				const rect = el.getBoundingClientRect();
				const textWidth = Math.min(getTextWidth(el), rect.width);

				// Shrink hitbox slightly from bottom to avoid overlap with artist
				const paddingX = 6;
				const shrinkBottom = 3;
				if (
					viewX >= rect.left - paddingX && viewX <= rect.left + textWidth + paddingX &&
					viewY >= rect.top && viewY <= rect.bottom - shrinkBottom
				) {
					return el;  // Return the element for context
				}
			}
			return null;
		};

		// Check if point is over any artist name in the main table
		const isOverTableArtistName = (x, y) => {
			const viewX = x - window.scrollX;
			const viewY = y - window.scrollY;
			const artistNames = document.querySelectorAll('tr.file .track-artist');

			for (const el of artistNames) {
				const rect = el.getBoundingClientRect();
				const textWidth = Math.min(getTextWidth(el), rect.width);

				// Shrink hitbox slightly from bottom
				const paddingX = 6;
				const shrinkBottom = 3;
				if (
					viewX >= rect.left - paddingX && viewX <= rect.left + textWidth + paddingX &&
					viewY >= rect.top && viewY <= rect.bottom - shrinkBottom
				) {
					return { element: el, artist: el.textContent };
				}
			}
			return null;
		};

		// Loupe magnification settings
		const LOUPE_SIZE = 160;
		const LOUPE_SCALE = 1.8;
		let loupeClone = null;

		// Create the magnified clone of page content for the loupe
		const createLoupeClone = () => {
			if (!loupeViewport) return;

			// Clone the entire page content area
			const mainContent = document.querySelector('.prose-content') || document.querySelector('main') || document.body;
			const contentRect = mainContent.getBoundingClientRect();

			loupeClone = mainContent.cloneNode(true);
			loupeClone.classList.add('loupe-clone');

			// Remove interactive/problematic elements from clone
			loupeClone.querySelectorAll('audio, video, script, style, #touch-loupe, #autonomous-pin').forEach(el => el.remove());

			// Fix mini player positioning in clone (it uses fixed/absolute positioning)
			const clonedMiniPlayer = loupeClone.querySelector('#mini-player');
			if (clonedMiniPlayer && miniPlayer) {
				const mpRect = miniPlayer.getBoundingClientRect();
				// Convert viewport coords to content-relative coords
				const relX = mpRect.left - contentRect.left;
				const relY = mpRect.top - contentRect.top;
				clonedMiniPlayer.style.cssText = `
					position: absolute !important;
					left: ${relX}px !important;
					top: ${relY}px !important;
					bottom: auto !important;
					right: auto !important;
					transform: none !important;
				`;
			}

			// Reset clone styles to match original layout
			loupeClone.style.cssText = `
				position: absolute;
				top: 0;
				left: 0;
				width: ${mainContent.offsetWidth}px;
				pointer-events: none;
				transform-origin: 0 0;
			`;

			// Clear viewport and add clone
			loupeViewport.innerHTML = '';
			loupeViewport.appendChild(loupeClone);
		};

		// Store original content position for loupe calculations
		let loupeContentOffsetX = 0;
		let loupeContentOffsetY = 0;

		// Update touch loupe - shows magnified view of what's under the pin
		const updateTouchLoupe = (touchX, touchY, pinCenterX, pinCenterY) => {
			if (!touchLoupe || !loupeViewport || !loupeClone) return;

			// Position loupe above the finger (so thumb doesn't cover it)
			// Clamp to viewport bounds (accounting for translateX(-50%) centering)
			const halfLoupe = LOUPE_SIZE / 2;
			const loupeX = Math.max(halfLoupe + 10, Math.min(window.innerWidth - halfLoupe - 10, touchX));
			const loupeY = Math.max(10, Math.min(window.innerHeight - LOUPE_SIZE - 10, touchY - 140));
			touchLoupe.style.left = loupeX + 'px';
			touchLoupe.style.top = loupeY + 'px';

			// Get the original content's position on screen
			const mainContent = document.querySelector('.prose-content') || document.querySelector('main') || document.body;
			const contentRect = mainContent.getBoundingClientRect();

			// Convert pin document coords to viewport coords
			const viewPinX = pinCenterX - window.scrollX;
			const viewPinY = pinCenterY - window.scrollY;

			// Pin position relative to the content element
			const relPinX = viewPinX - contentRect.left;
			const relPinY = viewPinY - contentRect.top;

			// Center of loupe
			const loupeCenterX = LOUPE_SIZE / 2;
			const loupeCenterY = LOUPE_SIZE / 2;

			// Translate clone so the pin position appears at loupe center
			// With scale(S) translate(X,Y), the translate happens in scaled space
			const translateX = (loupeCenterX - relPinX * LOUPE_SCALE) / LOUPE_SCALE;
			const translateY = (loupeCenterY - relPinY * LOUPE_SCALE) / LOUPE_SCALE;

			loupeClone.style.transform = `scale(${LOUPE_SCALE}) translate(${translateX}px, ${translateY}px)`;

			// Detect what's under the pin for border color
			let targetType = 'none';

			if (isOverTrackName(pinCenterX, pinCenterY)) {
				targetType = 'loop-track';
			} else if (isOverArtistName(pinCenterX, pinCenterY)) {
				targetType = 'loop-artist';
			} else {
				const tableTrackHit = isOverTableTrackName(pinCenterX, pinCenterY);
				if (tableTrackHit) {
					targetType = 'table-track';
				} else {
					const tableArtistHit = isOverTableArtistName(pinCenterX, pinCenterY);
					if (tableArtistHit) {
						targetType = 'table-artist';
					} else if (isOverMiniPlayer(pinCenterX, pinCenterY)) {
						targetType = 'mini-player';
					}
				}
			}

			touchLoupe.setAttribute('data-target', targetType);
		};

		// Show the touch loupe
		const showTouchLoupe = () => {
			if (touchLoupe && isTouchDevice) {
				createLoupeClone();
				touchLoupe.classList.remove('hidden');
			}
		};

		// Hide the touch loupe
		const hideTouchLoupe = () => {
			if (touchLoupe) {
				touchLoupe.classList.add('hidden');
				if (loupeViewport) loupeViewport.innerHTML = '';
				loupeClone = null;
			}
		};

		// Get where pin should rest when in loop mode (uses stored offset from card)
		const getLoopPinPosition = () => {
			// If pin is on table, return its current position (doesn't follow card)
			if (pinOnTable) {
				return { x: pinX, y: pinY };
			}

			// Get card's document position directly from its style (more reliable than bounding rect + scroll)
			const cardDocX = parseFloat(miniPlayer.style.left) || 0;
			const cardDocY = parseFloat(miniPlayer.style.top) || 0;

			if (isPinned) {
				// Return document coordinates
				return {
					x: cardDocX + loopPinOffsetX,
					y: cardDocY + loopPinOffsetY
				};
			}
			// For unpinned (fixed position), convert to viewport
			const cardRect = miniPlayer.getBoundingClientRect();
			return {
				x: cardRect.left + loopPinOffsetX,
				y: cardRect.top + loopPinOffsetY
			};
		};

		// Helper to wrap file extension in a span (so it stays default color)
		const wrapExtension = (filename) => {
			const lastDot = filename.lastIndexOf('.');
			if (lastDot > 0) {
				const base = filename.substring(0, lastDot);
				const ext = filename.substring(lastDot);
				return `${base}<span class="extension">${ext}</span>`;
			}
			return filename;
		};

		// Helper to get plain text from track name (strips any HTML)
		const getPlainTrackName = () => {
			return miniTrackNameEl.textContent;
		};

		// Show queued track indicator in mini player (after track name)
		const showQueuedTrack = (trackName) => {
			miniQueuedName.textContent = trackName;
			miniTrackQueued.classList.remove('hidden');
			miniArtistQueued.classList.add('hidden');  // Only one queue type at a time
		};

		// Show queued artist indicator in mini player (after artist name)
		const showQueuedArtist = (artistName) => {
			miniQueuedArtistName.textContent = artistName;
			miniArtistQueued.classList.remove('hidden');
			miniTrackQueued.classList.add('hidden');  // Only one queue type at a time
		};

		// Hide all queued indicators
		const hideQueuedTrack = () => {
			miniTrackQueued.classList.add('hidden');
			miniArtistQueued.classList.add('hidden');
		};

		// Activate track loop mode - pin settles on track name
		const activateLoopMode = () => {
			loopMode = true;
			artistLoopMode = false;  // Only one loop mode at a time
			loopArtist = '';

			// Only show loop symbol if not waiting for a queued track
			// (queued track means current track plays once, then queued track loops)
			if (!queuedLoopRow) {
				// Wrap extension in span so it stays default color
				const plainName = getPlainTrackName();
				miniTrackNameEl.innerHTML = wrapExtension(plainName);
				miniPlayerTrack.classList.add('loop-mode');
			}
			miniPlayerTrack.classList.remove('artist-loop-mode');
		};

		// Activate artist loop mode - pin settles on artist name
		// If artistName provided, loop that artist (from table drop); otherwise use current track's artist
		const activateArtistLoopMode = (artistName = null) => {
			artistLoopMode = true;
			loopMode = false;  // Only one loop mode at a time
			loopArtist = (artistName || miniTrackArtistEl.textContent).trim();  // Normalize whitespace

			// Restore plain text for track name (in case it had extension span)
			miniTrackNameEl.textContent = getPlainTrackName();

			// Highlight ALL matching artist names in the table
			const allArtists = document.querySelectorAll('tr.file .track-artist');
			allArtists.forEach(el => {
				if (el.textContent.trim() === loopArtist) {
					el.classList.add('pinned-loop');
				}
			});

			miniPlayerTrack.classList.add('artist-loop-mode');
			miniPlayerTrack.classList.remove('loop-mode');
		};

		// Deactivate all loop modes
		const deactivateLoopMode = () => {
			// Restore plain text for track name (in case it had extension span)
			if (loopMode) {
				miniTrackNameEl.textContent = getPlainTrackName();
			}

			// Remove pinned class from table element if any (for track loop)
			if (pinnedTableElement) {
				pinnedTableElement.classList.remove('pinned-loop');
				pinnedTableElement = null;
			}

			// Remove pinned class from ALL artist names (for artist loop)
			const allArtists = document.querySelectorAll('tr.file .track-artist.pinned-loop');
			allArtists.forEach(el => el.classList.remove('pinned-loop'));

			// If pin was on table and not currently being dragged, hide it
			// (it has no target to return to since mini player is floating)
			if (pinOnTable && !isPinDragging) {
				autonomousPin.classList.add('hidden');
				autonomousPin.classList.remove('resting', 'pinned');
			}

			loopMode = false;
			artistLoopMode = false;
			loopArtist = '';
			pinOnTable = false;
			autonomousPin.classList.remove('on-table');
			queuedLoopRow = null;  // Clear any queued track
			queuedLoopArtist = null;  // Clear any queued artist
			hideQueuedTrack();  // Hide the queued indicator
			miniPlayerTrack.classList.remove('loop-mode', 'artist-loop-mode');
		};

		// Animate pin flying from table back to mini player (when changing tracks while pin is on table)
		const animatePinReturnToMiniPlayer = () => {
			// Clear table visual state but don't hide the pin
			if (pinnedTableElement) {
				pinnedTableElement.classList.remove('pinned-loop');
				pinnedTableElement = null;
			}

			// Remove pinned class from ALL artist names
			const allArtists = document.querySelectorAll('tr.file .track-artist.pinned-loop');
			allArtists.forEach(el => el.classList.remove('pinned-loop'));

			// Clear loop mode state
			if (loopMode) {
				miniTrackNameEl.textContent = getPlainTrackName();
			}
			loopMode = false;
			artistLoopMode = false;
			loopArtist = '';
			pinOnTable = false;
			autonomousPin.classList.remove('on-table');
			queuedLoopRow = null;
			queuedLoopArtist = null;
			hideQueuedTrack();
			miniPlayerTrack.classList.remove('loop-mode', 'artist-loop-mode');

			// Check if mini player is currently moving (dragging or gliding)
			const isCardMoving = isDragging || miniPlayer.classList.contains('gliding');

			// Pin is currently in document coordinates (on table)
			// Get current position
			const currentPinX = parseFloat(autonomousPin.style.left) || 0;
			const currentPinY = parseFloat(autonomousPin.style.top) || 0;

			// CRITICAL: Pin the mini player FIRST (convert from fixed to absolute)
			// This ensures getPinTargetPosition returns document coords
			if (!isPinned) {
				const rect = miniPlayer.getBoundingClientRect();
				// Convert viewport coords to document coords
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;

				// Pin the mini player
				isPinned = true;
				miniPlayer.classList.add('pinned');
				autonomousPin.classList.add('pinned');
				miniPlayer.style.bottom = 'auto';
				miniPlayer.style.right = 'auto';
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';
			}

			// If card is moving, just enter chase mode - let normal chase logic handle it
			if (isCardMoving) {
				// Set pin position first (preserve table position)
				pinX = currentPinX;
				pinY = currentPinY;
				autonomousPin.style.transition = 'none';
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark as already lifted so onCardStartMoving doesn't reset position
				pinIsLifted = true;
				autonomousPin.classList.remove('resting', 'tacked');

				// Show needle in lifted state
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';

				// Always wait and watch first when coming from table
				// Pin assesses the situation before committing to chase
				pinWaitingForSlowdown = true;
				pinGaveUp = true;
				return;
			}

			// Card is stationary - do the fly-and-tack animation
			pinReturningFromTable = true;

			// Card should look elevated while pin approaches
			miniPlayer.classList.add('gliding');

			// Now get target position (will be in document coords since isPinned is true)
			const target = getPinTargetPosition();

			// Prepare pin for flight - show needle, remove resting state
			// CRITICAL: Set transition to none and ensure pin is at current position first
			autonomousPin.style.transition = 'none';
			autonomousPin.classList.remove('resting', 'tacked');
			autonomousPin.style.left = currentPinX + 'px';
			autonomousPin.style.top = currentPinY + 'px';
			pinNeedle.style.height = '15px';
			pinNeedle.style.opacity = '1';
			pinHead.style.transform = 'rotate(15deg)';
			pinNeedle.style.transform = 'rotate(15deg)';

			// Force reflow to apply current position before animating
			autonomousPin.offsetHeight;

			// Calculate flight distance for timing
			const dx = target.x - currentPinX;
			const dy = target.y - currentPinY;
			const distance = Math.sqrt(dx * dx + dy * dy);
			const flightTime = Math.min(300, Math.max(150, distance * 0.5));

			// Now set transition and animate to target
			autonomousPin.style.transition = `left ${flightTime}ms cubic-bezier(0.2, 0, 0.2, 1), top ${flightTime}ms cubic-bezier(0.2, 0, 0.2, 1)`;
			pinX = target.x;
			pinY = target.y;
			autonomousPin.style.left = pinX + 'px';
			autonomousPin.style.top = pinY + 'px';

			// After pin arrives, play tacking animation
			setTimeout(() => {
				autonomousPin.style.transition = '';

				// Pin tacking animation - needle shrinks as it enters
				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				// Card impact animation
				miniPlayer.classList.add('just-pinned');

				// After tacking animation completes, clean up
				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned', 'gliding');
					pinReturningFromTable = false;  // Clear flag - animation complete
					savePosition();
				}, 200);
			}, flightTime);
		};

		// ========== PIN DRAGGING FROM CARD ==========
		// Pull up on pin to remove it from card (same feel as pulling from page)
		let isPinDragging = false;
		let pinDragStartY = 0;
		let pinDragLifted = false;  // Has pin been pulled free?
		let pinDragFromTable = false;  // Track if drag started from table vs mini player
		let pinDragOriginalX = 0;
		let pinDragOriginalY = 0;
		const PIN_PULL_THRESHOLD = 25;  // How far to pull before pin comes free

		// Unpin the mini player (convert to fixed positioning)
		const unpinMiniPlayer = () => {
			if (!isPinned) return;

			// Deactivate loop mode when unpinning
			deactivateLoopMode();

			const rect = miniPlayer.getBoundingClientRect();
			// Convert to viewport coordinates for fixed positioning
			miniPlayer.style.left = rect.left + 'px';
			miniPlayer.style.top = rect.top + 'px';
			miniPlayer.classList.remove('pinned');
			isPinned = false;
			autonomousPin.classList.remove('pinned');
			savePosition();
		};

		// Pin drag start (mouse)
		autonomousPin.addEventListener('mousedown', (e) => {
			// Allow drag when pin is on mini player (isPinned) OR on table (pinOnTable)
			if ((!isPinned && !pinOnTable) || !autonomousPin.classList.contains('resting')) return;

			e.preventDefault();
			e.stopPropagation();

			isPinDragging = true;
			pinDragLifted = false;  // Always start with pull animation
			pinDragFromTable = pinOnTable;  // Remember where we started
			pinDragStartY = e.clientY;
			pinDragOriginalX = pinX;
			pinDragOriginalY = pinY;

			autonomousPin.classList.remove('resting');
		});

		// Pin drag move (mouse) - pull up to remove, like pulling from page
		document.addEventListener('mousemove', (e) => {
			if (!isPinDragging) return;

			const deltaY = e.clientY - pinDragStartY;
			const pullDistance = -deltaY;  // Positive when pulling up

			if (!pinDragLifted) {
				if (pullDistance > 0) {
					// Pulling up - show needle emerging gradually
					const progress = Math.min(1, pullDistance / PIN_PULL_THRESHOLD);
					const needleHeight = progress * 15;
					const liftAmount = progress * 8;

					pinNeedle.style.height = needleHeight + 'px';
					pinNeedle.style.opacity = progress.toString();
					autonomousPin.style.transform = `translateY(${-liftAmount}px)`;

					const rotation = progress * 15;
					pinHead.style.transform = `rotate(${rotation}deg)`;
					pinNeedle.style.transform = `rotate(${rotation}deg)`;

					if (progress >= 1) {
						// Fully pulled out!
						pinDragLifted = true;
						autonomousPin.classList.add('dragging');

						// CRITICAL: Set fixed position and viewport coords BEFORE unpinning
						const viewPinX = e.clientX - 10;
						const viewPinY = e.clientY - 5;
						autonomousPin.style.position = 'fixed';
						autonomousPin.style.transform = '';
						autonomousPin.style.left = viewPinX + 'px';
						autonomousPin.style.top = viewPinY + 'px';

						// Handle differently based on where we pulled from
						if (pinDragFromTable) {
							// Pulling from table - deactivate loop mode (this also resets pinOnTable)
							deactivateLoopMode();
							autonomousPin.classList.remove('pinned');
						} else {
							// Pulling from mini player - unpin the card
							unpinMiniPlayer();
						}

						// Store document coords for drop detection
						pinX = viewPinX + window.scrollX;
						pinY = viewPinY + window.scrollY;
					}
				} else {
					// Pushing down or not moving - reset
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					autonomousPin.style.transform = '';
				}
				return;
			}

			// Pin is lifted - follow cursor
			// Use viewport coords for display (fixed positioning)
			const viewPinX = e.clientX - 10;
			const viewPinY = e.clientY - 5;
			// Store document coords for drop detection
			pinX = viewPinX + window.scrollX;
			pinY = viewPinY + window.scrollY;

			autonomousPin.style.transform = '';
			autonomousPin.style.left = viewPinX + 'px';
			autonomousPin.style.top = viewPinY + 'px';
		});

		// Pin drag end (mouse)
		document.addEventListener('mouseup', () => {
			if (!isPinDragging) return;

			isPinDragging = false;
			pinDragFromTable = false;  // Reset for next drag
			autonomousPin.style.transform = '';

			if (!pinDragLifted) {
				// Pin wasn't pulled out - reset visuals
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';
				pinHead.style.transform = '';
				pinNeedle.style.transform = '';
				autonomousPin.classList.add('resting');
				return;
			}

			autonomousPin.classList.remove('dragging');

			// Get pin head center for accurate hit detection
			// Pin head is at top:1px, left:6.5px and is 8x8px, so center is at (10.5, 5) from element
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;

			// Check table artist name first (larger remote drop target)
			const tableArtistHit = isOverTableArtistName(pinHeadCenterX, pinHeadCenterY);
			if (tableArtistHit) {
				// Dropped on table artist name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableArtistHit.element;
				pinnedTableElement.classList.add('pinned-loop');

				// Check if this is a different artist than currently playing
				const currentArtist = miniTrackArtistEl?.textContent || '';
				if (tableArtistHit.artist !== currentArtist) {
					// Queue this artist - will activate when current track ends
					queuedLoopArtist = tableArtistHit.artist;
					queuedLoopRow = null;  // Clear any track queue
					showQueuedArtist(tableArtistHit.artist);  // Show "[Artist]" as queued
				} else {
					// Same artist - activate immediately
					activateArtistLoopMode(tableArtistHit.artist);
				}

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check table track name (larger remote drop target)
			const tableTrackHit = isOverTableTrackName(pinHeadCenterX, pinHeadCenterY);
			if (tableTrackHit) {
				// Dropped on table track name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableTrackHit;
				pinnedTableElement.classList.add('pinned-loop');

				// If this is a different track than currently playing, queue it to play when current ends
				const targetRow = tableTrackHit.closest('tr');
				if (targetRow && targetRow !== currentRow) {
					queuedLoopRow = targetRow;  // Will play when current track ends
					queuedLoopArtist = null;  // Clear any artist queue
					// Show queued track in mini player
					const queuedTrackName = targetRow.querySelector('.track-name')?.textContent || '';
					showQueuedTrack(queuedTrackName);
				}

				// Activate track loop mode (mini player shows indicator)
				activateLoopMode();

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check mini player artist name FIRST (it's lower, more specific target)
			// If we checked track name first, overlap would always favor track
			if (isOverArtistName(pinHeadCenterX, pinHeadCenterY)) {
				// Dropped on artist name - activate artist loop mode!
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Pin stays exactly where user dropped it
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Store pin offset relative to card's document position
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				loopPinOffsetX = pinX - cardDocX;
				loopPinOffsetY = pinY - cardDocY;

				// Pin the card and activate artist loop mode
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;
				activateArtistLoopMode();

				// Pin tacking animation at drop location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else if (isOverTrackName(pinHeadCenterX, pinHeadCenterY)) {
				// Dropped on track name - activate track loop mode!
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Pin stays exactly where user dropped it
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Store pin offset relative to card's document position
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				loopPinOffsetX = pinX - cardDocX;
				loopPinOffsetY = pinY - cardDocY;

				// Pin the card and activate track loop mode
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;
				activateLoopMode();

				// Pin tacking animation at drop location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else if (isOverMiniPlayer(pinHeadCenterX, pinHeadCenterY)) {
				// Check if dropped on/near the mini player - re-pin it (normal mode)
				// Rewritten to match track name tacking structure (no flash)
				deactivateLoopMode();
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Calculate target position (tack spot on card)
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				const cardWidth = rect.width;
				pinX = cardDocX + cardWidth - 25;
				pinY = cardDocY + 8;

				// Switch pin to absolute positioning at target location (no slide animation)
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Pin the card and mark as pinned
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;

				// Pin tacking animation at tack location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else {
				// Tack pin into page with animation
				// CRITICAL: Set position to absolute BEFORE setting document coords
				// Otherwise we're setting doc coords on a fixed element = wrong position
				autonomousPin.style.position = 'absolute';
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';

				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('tacked');
					autonomousPin.style.position = '';  // Clear inline, let class handle it
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
				}, 200);
			}
		});

		// Pin drag start (touch)
		autonomousPin.addEventListener('touchstart', (e) => {
			// Allow drag when pin is on mini player (isPinned) OR on table (pinOnTable)
			if ((!isPinned && !pinOnTable) || !autonomousPin.classList.contains('resting')) return;

			e.stopPropagation();

			const touch = e.touches[0];
			isPinDragging = true;
			pinDragLifted = false;  // Always start with pull animation
			pinDragFromTable = pinOnTable;  // Remember where we started
			pinDragStartY = touch.clientY;
			pinDragOriginalX = pinX;
			pinDragOriginalY = pinY;

			autonomousPin.classList.remove('resting');
		}, { passive: true });

		// Pin drag move (touch) - pull up to remove
		document.addEventListener('touchmove', (e) => {
			if (!isPinDragging) return;
			if (!e.touches.length) return;  // Guard against no touches

			const touch = e.touches[0];
			const deltaY = touch.clientY - pinDragStartY;
			const pullDistance = -deltaY;

			if (!pinDragLifted) {
				if (pullDistance > 0) {
					const progress = Math.min(1, pullDistance / PIN_PULL_THRESHOLD);
					const needleHeight = progress * 15;
					const liftAmount = progress * 8;

					pinNeedle.style.height = needleHeight + 'px';
					pinNeedle.style.opacity = progress.toString();
					autonomousPin.style.transform = `translateY(${-liftAmount}px)`;

					const rotation = progress * 15;
					pinHead.style.transform = `rotate(${rotation}deg)`;
					pinNeedle.style.transform = `rotate(${rotation}deg)`;

					if (progress >= 1) {
						pinDragLifted = true;
						autonomousPin.classList.add('dragging');

						// CRITICAL: Set fixed position and viewport coords BEFORE unpinning
						const viewPinX = touch.clientX - 10;
						const viewPinY = touch.clientY - 5;
						autonomousPin.style.position = 'fixed';
						autonomousPin.style.transform = '';
						autonomousPin.style.left = viewPinX + 'px';
						autonomousPin.style.top = viewPinY + 'px';

						// Handle differently based on where we pulled from
						if (pinDragFromTable) {
							// Pulling from table - deactivate loop mode (this also resets pinOnTable)
							deactivateLoopMode();
							autonomousPin.classList.remove('pinned');
						} else {
							// Pulling from mini player - unpin the card
							unpinMiniPlayer();
						}

						// Store document coords for drop detection
						pinX = viewPinX + window.scrollX;
						pinY = viewPinY + window.scrollY;

						// Show touch loupe when pin is lifted
						showTouchLoupe();
						const pinHeadCenterX = pinX + 10.5;
						const pinHeadCenterY = pinY + 5;
						updateTouchLoupe(touch.clientX, touch.clientY, pinHeadCenterX, pinHeadCenterY);
					}
				} else {
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					autonomousPin.style.transform = '';
				}
				return;
			}

			// Pin is lifted - follow touch
			// Use viewport coords for display (fixed positioning)
			const viewPinX = touch.clientX - 10;
			const viewPinY = touch.clientY - 5;
			// Store document coords for drop detection
			pinX = viewPinX + window.scrollX;
			pinY = viewPinY + window.scrollY;

			autonomousPin.style.transform = '';
			autonomousPin.style.left = viewPinX + 'px';
			autonomousPin.style.top = viewPinY + 'px';

			// Update touch loupe
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;
			updateTouchLoupe(touch.clientX, touch.clientY, pinHeadCenterX, pinHeadCenterY);
		}, { passive: true });

		// Pin drag end (touch)
		document.addEventListener('touchend', () => {
			if (!isPinDragging) return;

			// Hide touch loupe
			hideTouchLoupe();

			isPinDragging = false;
			pinDragFromTable = false;  // Reset for next drag
			autonomousPin.style.transform = '';

			if (!pinDragLifted) {
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';
				pinHead.style.transform = '';
				pinNeedle.style.transform = '';
				autonomousPin.classList.add('resting');
				return;
			}

			autonomousPin.classList.remove('dragging');

			// Get pin head center for accurate hit detection
			// Pin head is at top:1px, left:6.5px and is 8x8px, so center is at (10.5, 5) from element
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;

			// Check table artist name first (larger remote drop target)
			const tableArtistHit = isOverTableArtistName(pinHeadCenterX, pinHeadCenterY);
			if (tableArtistHit) {
				// Dropped on table artist name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableArtistHit.element;
				pinnedTableElement.classList.add('pinned-loop');

				// Check if this is a different artist than currently playing
				const currentArtist = miniTrackArtistEl?.textContent || '';
				if (tableArtistHit.artist !== currentArtist) {
					// Queue this artist - will activate when current track ends
					queuedLoopArtist = tableArtistHit.artist;
					queuedLoopRow = null;  // Clear any track queue
					showQueuedArtist(tableArtistHit.artist);  // Show "[Artist]" as queued
				} else {
					// Same artist - activate immediately
					activateArtistLoopMode(tableArtistHit.artist);
				}

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check table track name (larger remote drop target)
			const tableTrackHit = isOverTableTrackName(pinHeadCenterX, pinHeadCenterY);
			if (tableTrackHit) {
				// Dropped on table track name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableTrackHit;
				pinnedTableElement.classList.add('pinned-loop');

				// If this is a different track than currently playing, queue it to play when current ends
				const targetRow = tableTrackHit.closest('tr');
				if (targetRow && targetRow !== currentRow) {
					queuedLoopRow = targetRow;  // Will play when current track ends
					queuedLoopArtist = null;  // Clear any artist queue
					// Show queued track in mini player
					const queuedTrackName = targetRow.querySelector('.track-name')?.textContent || '';
					showQueuedTrack(queuedTrackName);
				}

				// Activate track loop mode (mini player shows indicator)
				activateLoopMode();

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check mini player artist name FIRST (it's lower, more specific target)
			if (isOverArtistName(pinHeadCenterX, pinHeadCenterY)) {
				// Dropped on artist name - activate artist loop mode!
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Pin stays exactly where user dropped it
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Store pin offset relative to card's document position
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				loopPinOffsetX = pinX - cardDocX;
				loopPinOffsetY = pinY - cardDocY;

				// Pin the card and activate artist loop mode
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;
				activateArtistLoopMode();

				// Pin tacking animation at drop location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else if (isOverTrackName(pinHeadCenterX, pinHeadCenterY)) {
				// Dropped on track name - activate track loop mode!
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Pin stays exactly where user dropped it
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Store pin offset relative to card's document position
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				loopPinOffsetX = pinX - cardDocX;
				loopPinOffsetY = pinY - cardDocY;

				// Pin the card and activate track loop mode
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;
				activateLoopMode();

				// Pin tacking animation at drop location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else if (isOverMiniPlayer(pinHeadCenterX, pinHeadCenterY)) {
				// Check if dropped on/near the mini player - re-pin it (normal mode)
				// Rewritten to match track name tacking structure (no flash)
				deactivateLoopMode();
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Calculate target position (tack spot on card)
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				const cardWidth = rect.width;
				pinX = cardDocX + cardWidth - 25;
				pinY = cardDocY + 8;

				// Switch pin to absolute positioning at target location (no slide animation)
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Pin the card and mark as pinned
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;

				// Pin tacking animation at tack location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else {
				// Tack pin into page
				// CRITICAL: Set position to absolute BEFORE setting document coords
				autonomousPin.style.position = 'absolute';
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';

				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('tacked');
					autonomousPin.style.position = '';  // Clear inline, let class handle it
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
				}, 200);
			}
		});

		// Handle interrupted pin drag (incoming call, gesture conflict, etc.)
		document.addEventListener('touchcancel', () => {
			if (!isPinDragging) return;

			// Hide touch loupe
			hideTouchLoupe();

			isPinDragging = false;
			pinDragFromTable = false;
			autonomousPin.style.transform = '';

			// Reset pin visuals
			pinNeedle.style.height = '0';
			pinNeedle.style.opacity = '0';
			pinHead.style.transform = '';
			pinNeedle.style.transform = '';

			if (pinDragLifted) {
				autonomousPin.classList.remove('dragging');
				// Pin was lifted but touch cancelled - return to original position
				autonomousPin.style.position = '';
				autonomousPin.style.left = pinDragOriginalX + 'px';
				autonomousPin.style.top = pinDragOriginalY + 'px';
				pinX = pinDragOriginalX;
				pinY = pinDragOriginalY;
			}
			autonomousPin.classList.add('resting');
		});

		// ========== TACKED PIN DRAGGING ==========
		// Pull up on a tacked pin to remove it, then drag to reposition
		let isTackedPinDragging = false;
		let tackedPinStartY = 0;
		let tackedPinLifted = false;
		let tackedPinOriginalX = 0;
		let tackedPinOriginalY = 0;

		// Tacked pin drag start (mouse)
		autonomousPin.addEventListener('mousedown', (e) => {
			if (!autonomousPin.classList.contains('tacked')) return;

			e.preventDefault();
			e.stopPropagation();

			isTackedPinDragging = true;
			tackedPinLifted = false;
			tackedPinStartY = e.clientY;
			tackedPinOriginalX = pinX;
			tackedPinOriginalY = pinY;

			// Store the scroll position at drag start
			const scrollAtStart = window.scrollY;
			autonomousPin.dataset.scrollStart = scrollAtStart;
		});

		// Tacked pin drag move (mouse)
		document.addEventListener('mousemove', (e) => {
			if (!isTackedPinDragging) return;

			const deltaY = e.clientY - tackedPinStartY;
			const pullDistance = -deltaY; // Positive when pulling up
			const pullThreshold = 25; // How far to pull before pin comes free

			if (!tackedPinLifted) {
				if (pullDistance > 0) {
					// Pulling up - show needle emerging from page
					const progress = Math.min(1, pullDistance / pullThreshold);
					const needleHeight = progress * 15;
					const liftAmount = progress * 8; // Pin lifts as you pull

					pinNeedle.style.height = needleHeight + 'px';
					pinNeedle.style.opacity = progress.toString();
					autonomousPin.style.transform = `translateY(${-liftAmount}px)`;

					// Slight rotation as it lifts
					const rotation = progress * 15;
					pinHead.style.transform = `rotate(${rotation}deg)`;
					pinNeedle.style.transform = `rotate(${rotation}deg)`;

					if (progress >= 1) {
						// Fully pulled out!
						tackedPinLifted = true;

						// CRITICAL: Set fixed position and viewport coords BEFORE removing class
						// This prevents a flash where pin has fixed position but document coords
						const viewPinX = e.clientX - 10;
						const viewPinY = e.clientY - 5;
						autonomousPin.style.position = 'fixed';
						autonomousPin.style.transform = '';
						autonomousPin.style.left = viewPinX + 'px';
						autonomousPin.style.top = viewPinY + 'px';

						// NOW safe to remove class
						autonomousPin.classList.remove('tacked');
						autonomousPin.classList.add('dragging');

						// Store document coords for drop detection
						pinX = viewPinX + window.scrollX;
						pinY = viewPinY + window.scrollY;
					}
				} else {
					// Pushing down or not moving - reset
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					autonomousPin.style.transform = '';
				}
				return;
			}

			// Pin is lifted - follow cursor
			// Use viewport coords for display (fixed positioning)
			const viewPinX = e.clientX - 10;
			const viewPinY = e.clientY - 5;
			// Store document coords for drop detection
			pinX = viewPinX + window.scrollX;
			pinY = viewPinY + window.scrollY;

			autonomousPin.style.transform = '';
			autonomousPin.style.left = viewPinX + 'px';
			autonomousPin.style.top = viewPinY + 'px';
		});

		// Tacked pin drag end (mouse)
		document.addEventListener('mouseup', (e) => {
			if (!isTackedPinDragging) return;

			isTackedPinDragging = false;
			autonomousPin.style.transform = '';

			if (!tackedPinLifted) {
				// Pin wasn't pulled out - reset visuals and stay tacked
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';
				pinHead.style.transform = '';
				pinNeedle.style.transform = '';
				return;
			}

			autonomousPin.classList.remove('dragging');

			// Calculate pin head center for accurate hit detection
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;

			// Check table artist name first (larger remote drop target)
			const tableArtistHit = isOverTableArtistName(pinHeadCenterX, pinHeadCenterY);
			if (tableArtistHit) {
				// Dropped on table artist name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableArtistHit.element;
				pinnedTableElement.classList.add('pinned-loop');

				// Activate artist loop mode OR queue if different artist
				const currentArtist = miniTrackArtistEl?.textContent || '';
				if (tableArtistHit.artist !== currentArtist) {
					// Different artist - queue it instead of immediate activation
					queuedLoopArtist = tableArtistHit.artist;
					queuedLoopRow = null;
					showQueuedArtist(tableArtistHit.artist);
				} else {
					// Same artist - activate immediately
					activateArtistLoopMode(tableArtistHit.artist);
				}

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check table track name (larger remote drop target)
			const tableTrackHit = isOverTableTrackName(pinHeadCenterX, pinHeadCenterY);
			if (tableTrackHit) {
				// Dropped on table track name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableTrackHit;
				pinnedTableElement.classList.add('pinned-loop');

				// If this is a different track than currently playing, queue it to play when current ends
				const targetRow = tableTrackHit.closest('tr');
				if (targetRow && targetRow !== currentRow) {
					queuedLoopRow = targetRow;  // Will play when current track ends
					queuedLoopArtist = null;  // Clear any artist queue
					// Show queued track in mini player
					const queuedTrackName = targetRow.querySelector('.track-name')?.textContent || '';
					showQueuedTrack(queuedTrackName);
				}

				// Activate track loop mode (mini player shows indicator)
				activateLoopMode();

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
				return;
			}

			// Check if dropped on mini player track name - activate loop mode!
			if (isOverTrackName(pinX, pinY)) {
				// Stop any ongoing glide animation
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Convert pin's current viewport position to document coords
				// Pin stays exactly where user dropped it
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Store pin offset relative to card's document position
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				loopPinOffsetX = pinX - cardDocX;
				loopPinOffsetY = pinY - cardDocY;

				// Pin the card and activate loop mode
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;
				activateLoopMode();

				// Pin tacking animation at drop location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else if (isOverMiniPlayer(pinHeadCenterX, pinHeadCenterY)) {
				// Check if dropped on mini player (normal mode)
				// Rewritten to match track name tacking structure (no flash)
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Calculate target position (tack spot on card)
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				const cardWidth = rect.width;
				pinX = cardDocX + cardWidth - 25;
				pinY = cardDocY + 8;

				// Switch pin to absolute positioning at target location (no slide animation)
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Pin the card and mark as pinned
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;

				// Pin tacking animation at tack location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else {
				// Tack into new position
				// CRITICAL: Set position to absolute BEFORE setting document coords
				autonomousPin.style.position = 'absolute';
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Needle is already visible from being dragged - just ensure correct state
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';

				// Force reflow before animation
				autonomousPin.offsetHeight;

				// Now animate tacking - needle will shrink via CSS transition
				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('tacked');
					autonomousPin.style.position = '';  // Clear inline, let class handle it
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
				}, 200);
			}
		});

		// Tacked pin drag (touch)
		autonomousPin.addEventListener('touchstart', (e) => {
			if (!autonomousPin.classList.contains('tacked')) return;

			e.stopPropagation();

			const touch = e.touches[0];
			isTackedPinDragging = true;
			tackedPinLifted = false;
			tackedPinStartY = touch.clientY;
			tackedPinOriginalX = pinX;
			tackedPinOriginalY = pinY;
		}, { passive: true });

		document.addEventListener('touchmove', (e) => {
			if (!isTackedPinDragging) return;
			if (!e.touches.length) return;  // Guard against no touches

			const touch = e.touches[0];
			const deltaY = touch.clientY - tackedPinStartY;
			const pullDistance = -deltaY;
			const pullThreshold = 25;

			if (!tackedPinLifted) {
				if (pullDistance > 0) {
					// Pulling up - show needle emerging from page
					const progress = Math.min(1, pullDistance / pullThreshold);
					const needleHeight = progress * 15;
					const liftAmount = progress * 8;

					pinNeedle.style.height = needleHeight + 'px';
					pinNeedle.style.opacity = progress.toString();
					autonomousPin.style.transform = `translateY(${-liftAmount}px)`;

					const rotation = progress * 15;
					pinHead.style.transform = `rotate(${rotation}deg)`;
					pinNeedle.style.transform = `rotate(${rotation}deg)`;

					if (progress >= 1) {
						tackedPinLifted = true;

						// CRITICAL: Set fixed position and viewport coords BEFORE removing class
						const viewPinX = touch.clientX - 10;
						const viewPinY = touch.clientY - 5;
						autonomousPin.style.position = 'fixed';
						autonomousPin.style.transform = '';
						autonomousPin.style.left = viewPinX + 'px';
						autonomousPin.style.top = viewPinY + 'px';

						// NOW safe to remove class
						autonomousPin.classList.remove('tacked');
						autonomousPin.classList.add('dragging');

						// Store document coords for drop detection
						pinX = viewPinX + window.scrollX;
						pinY = viewPinY + window.scrollY;

						// Show touch loupe when tacked pin is lifted
						showTouchLoupe();
						const pinHeadCenterX = pinX + 10.5;
						const pinHeadCenterY = pinY + 5;
						updateTouchLoupe(touch.clientX, touch.clientY, pinHeadCenterX, pinHeadCenterY);
					}
				} else {
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					autonomousPin.style.transform = '';
				}
				return;
			}

			// Pin is lifted - follow touch
			// Use viewport coords for display (fixed positioning)
			const viewPinX = touch.clientX - 10;
			const viewPinY = touch.clientY - 5;
			// Store document coords for drop detection
			pinX = viewPinX + window.scrollX;
			pinY = viewPinY + window.scrollY;

			autonomousPin.style.transform = '';
			autonomousPin.style.left = viewPinX + 'px';
			autonomousPin.style.top = viewPinY + 'px';

			// Update touch loupe
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;
			updateTouchLoupe(touch.clientX, touch.clientY, pinHeadCenterX, pinHeadCenterY);
		}, { passive: true });

		document.addEventListener('touchend', (e) => {
			if (!isTackedPinDragging) return;

			// Hide touch loupe
			hideTouchLoupe();

			isTackedPinDragging = false;
			autonomousPin.style.transform = '';

			if (!tackedPinLifted) {
				// Pin wasn't pulled out - reset visuals and stay tacked
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';
				pinHead.style.transform = '';
				pinNeedle.style.transform = '';
				return;
			}

			autonomousPin.classList.remove('dragging');

			// Calculate pin head center for accurate hit detection
			const pinHeadCenterX = pinX + 10.5;
			const pinHeadCenterY = pinY + 5;

			// Check table artist name first (larger remote drop target)
			const tableArtistHit = isOverTableArtistName(pinHeadCenterX, pinHeadCenterY);
			if (tableArtistHit) {
				// Dropped on table artist name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableArtistHit.element;
				pinnedTableElement.classList.add('pinned-loop');

				// Activate artist loop mode OR queue if different artist
				const currentArtist = miniTrackArtistEl?.textContent || '';
				if (tableArtistHit.artist !== currentArtist) {
					// Different artist - queue it instead of immediate activation
					queuedLoopArtist = tableArtistHit.artist;
					queuedLoopRow = null;
					showQueuedArtist(tableArtistHit.artist);
				} else {
					// Same artist - activate immediately
					activateArtistLoopMode(tableArtistHit.artist);
				}

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					savePosition();
				}, 200);
				return;
			}

			// Check table track name (larger remote drop target)
			const tableTrackHit = isOverTableTrackName(pinHeadCenterX, pinHeadCenterY);
			if (tableTrackHit) {
				// Dropped on table track name - pin stays on table, mini player stays floating
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Pin stays exactly where dropped (on the table) - use document coords
				const pinRect = autonomousPin.getBoundingClientRect();
				pinX = pinRect.left + window.scrollX;
				pinY = pinRect.top + window.scrollY;

				// Switch pin to absolute positioning at drop location
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Mark pin as on table (detached from mini player)
				// Mini player stays floating (NOT pinned) since pin is on table
				pinOnTable = true;
				autonomousPin.classList.add('on-table');
				pinnedTableElement = tableTrackHit;
				pinnedTableElement.classList.add('pinned-loop');

				// If this is a different track than currently playing, queue it to play when current ends
				const targetRow = tableTrackHit.closest('tr');
				if (targetRow && targetRow !== currentRow) {
					queuedLoopRow = targetRow;  // Will play when current track ends
					queuedLoopArtist = null;  // Clear any artist queue
					// Show queued track in mini player
					const queuedTrackName = targetRow.querySelector('.track-name')?.textContent || '';
					showQueuedTrack(queuedTrackName);
				}

				// Activate track loop mode (mini player shows indicator)
				activateLoopMode();

				// Pin tacking animation at table location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
				return;
			}

			// Check if dropped on mini player track name - activate loop mode!
			if (isOverTrackName(pinX, pinY)) {
				// Stop any ongoing glide animation
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Clear inline position before adding .pinned class
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');

				// Slide pin to loop position (on track name)
				const target = getLoopPinPosition();
				autonomousPin.style.transition = 'left 0.12s ease-out, top 0.12s ease-out';
				pinX = target.x;
				pinY = target.y;
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// After pin arrives, activate loop mode
				setTimeout(() => {
					autonomousPin.style.transition = '';

					miniPlayer.classList.add('pinned');
					miniPlayer.classList.add('just-pinned-from-float');
					isPinned = true;

					// Activate loop mode
					activateLoopMode();

					// Pin tacking animation
					pinNeedle.style.transition = 'none';
					pinNeedle.style.height = '15px';
					pinNeedle.style.opacity = '1';
					pinHead.style.transform = 'rotate(15deg)';
					pinNeedle.style.transform = 'rotate(15deg)';
					autonomousPin.offsetHeight;

					pinNeedle.style.transition = '';
					autonomousPin.classList.add('tacking');
					pinNeedle.style.height = '0';
					pinNeedle.style.opacity = '0';

					setTimeout(() => {
						autonomousPin.classList.remove('tacking');
						autonomousPin.classList.add('resting');
						pinHead.style.transform = '';
						pinNeedle.style.transform = '';
						miniPlayer.classList.remove('just-pinned-from-float');
						savePosition();
					}, 200);
				}, 120);
			} else if (isOverMiniPlayer(pinHeadCenterX, pinHeadCenterY)) {
				// Check if dropped on mini player (normal mode)
				// Rewritten to match track name tacking structure (no flash)
				stopAnimation();
				miniPlayer.classList.remove('gliding', 'dragging');

				// Convert mini player to document coords for pinned positioning
				const rect = miniPlayer.getBoundingClientRect();
				const docX = rect.left + window.scrollX;
				const docY = rect.top + window.scrollY;
				miniPlayer.style.left = docX + 'px';
				miniPlayer.style.top = docY + 'px';

				// Calculate target position (tack spot on card)
				const cardDocX = parseFloat(miniPlayer.style.left) || 0;
				const cardDocY = parseFloat(miniPlayer.style.top) || 0;
				const cardWidth = rect.width;
				pinX = cardDocX + cardWidth - 25;
				pinY = cardDocY + 8;

				// Switch pin to absolute positioning at target location (no slide animation)
				autonomousPin.style.position = '';
				autonomousPin.classList.add('pinned');
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				// Pin the card and mark as pinned
				miniPlayer.classList.add('pinned');
				miniPlayer.classList.add('just-pinned-from-float');
				isPinned = true;

				// Pin tacking animation at tack location
				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';
				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('resting');
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
					miniPlayer.classList.remove('just-pinned-from-float');
					savePosition();
				}, 200);
			} else {
				// Tack into new position
				// CRITICAL: Set position to absolute BEFORE setting document coords
				autonomousPin.style.position = 'absolute';
				autonomousPin.style.left = pinX + 'px';
				autonomousPin.style.top = pinY + 'px';

				pinNeedle.style.transition = 'none';
				pinNeedle.style.height = '15px';
				pinNeedle.style.opacity = '1';
				pinHead.style.transform = 'rotate(15deg)';
				pinNeedle.style.transform = 'rotate(15deg)';

				autonomousPin.offsetHeight;

				pinNeedle.style.transition = '';
				autonomousPin.classList.add('tacking');
				pinNeedle.style.height = '0';
				pinNeedle.style.opacity = '0';

				setTimeout(() => {
					autonomousPin.classList.remove('tacking');
					autonomousPin.classList.add('tacked');
					autonomousPin.style.position = '';  // Clear inline, let class handle it
					pinHead.style.transform = '';
					pinNeedle.style.transform = '';
				}, 200);
			}
		});

		// Handle interrupted tacked pin drag (incoming call, gesture conflict, etc.)
		document.addEventListener('touchcancel', () => {
			if (!isTackedPinDragging) return;

			// Hide touch loupe
			hideTouchLoupe();

			isTackedPinDragging = false;
			autonomousPin.style.transform = '';

			// Reset pin visuals
			pinNeedle.style.height = '0';
			pinNeedle.style.opacity = '0';
			pinHead.style.transform = '';
			pinNeedle.style.transform = '';

			if (tackedPinLifted) {
				autonomousPin.classList.remove('dragging');
				// Pin was lifted but touch cancelled - return to original tacked position
				autonomousPin.style.position = 'absolute';
				autonomousPin.style.left = tackedPinOriginalX + 'px';
				autonomousPin.style.top = tackedPinOriginalY + 'px';
				pinX = tackedPinOriginalX;
				pinY = tackedPinOriginalY;
				autonomousPin.classList.add('tacked');
			}
		});

		// Revalidate position on window resize
		// Skip if animation is active (mobile browser bar changes trigger resize)
		window.addEventListener('resize', () => {
			if (miniPlayer.classList.contains('dragged') && !animationId) {
				const pos = getPosition();
				const maxX = window.innerWidth - miniPlayer.offsetWidth;
				const maxY = window.innerHeight - miniPlayer.offsetHeight;

				if (pos.x > maxX || pos.y > maxY) {
					setPosition(Math.min(pos.x, maxX), Math.min(pos.y, maxY));
					savePosition();
				}
			}
		});

		// Load saved position when mini player first shows
		const originalUpdateMiniPlayer = updateMiniPlayer;
		const updateMiniPlayerWithPosition = () => {
			const wasHidden = miniPlayer.classList.contains('hidden');
			if (wasHidden) {
				// Remove display:none but keep invisible for dimension calculations
				miniPlayer.classList.remove('hidden');
				miniPlayer.style.visibility = 'hidden';
			}
			originalUpdateMiniPlayer();
			if (wasHidden) {
				// Position and animate (player has dimensions now)
				loadSavedPosition();
				// Now make visible - pinned state is already set
				miniPlayer.style.visibility = '';
			}
		};
		audioPlayer.removeEventListener('play', updateMiniPlayer);
		audioPlayer.addEventListener('play', updateMiniPlayerWithPosition);
	</script>
</Layout>
